var tipuesearch = {"pages":[{"title":" GVTD-HeCs ","text":"GVTD-HeCs Developer Info Satoki Tsujino","tags":"home","loc":"index.html"},{"title":"matrix_sum – GVTD-HeCs","text":"public function matrix_sum(aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:) Matrix A1 double precision, intent(in) :: akj (size(aij)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij)) Undefined flag at each sampling point Return Value doubleprecision Contents None","tags":"","loc":"proc/matrix_sum.html"},{"title":"Retrieve_velocity_GVTD – GVTD-HeCs","text":"public subroutine Retrieve_velocity_GVTD(nasym, r, t, td, Vd, Un, Vn, RadTC, VT, VR, VT0, VR0, VTSn, VTCn, undef) Solve unknown variables and return wind velocity on R-T coordinates\n  based on the GVTD technique. ------------------------------------------------------ [relationship between r and rh] -- ------------------------------------------------------ i-1    i    i+1 ...|-- --|-- --|... : r(1:size(r)) = velocity radii Arguments Type Intent Optional Attributes Name integer, intent(in) :: nasym wave number for asymmetric tangential wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VTSn (nasym,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VTCn (nasym,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd Calls proc~~retrieve_velocity_gvtd~~CallsGraph proc~retrieve_velocity_gvtd Retrieve_velocity_GVTD proc~stdout stdout proc~retrieve_velocity_gvtd->proc~stdout dcos dcos proc~retrieve_velocity_gvtd->dcos proc~fp_gauss fp_gauss proc~retrieve_velocity_gvtd->proc~fp_gauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/retrieve_velocity_gvtd.html"},{"title":"line_integral – GVTD-HeCs","text":"public function line_integral(nr, rdh, gkrr, div_r, undef) Calculate a line integral (actually, sum for arguments) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr Radial grid number double precision, intent(in) :: rdh (nr+1) R-coordinate [m] double precision, intent(in) :: gkrr (nr+1) Green function double precision, intent(in) :: div_r (nr+1) Integral of gkrr double precision, intent(in), optional :: undef Undefined value Return Value doubleprecision Called by proc~~line_integral~~CalledByGraph proc~line_integral line_integral proc~prod_vortex_structure prod_vortex_structure proc~prod_vortex_structure->proc~line_integral Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/line_integral.html"},{"title":"green_func – GVTD-HeCs","text":"public function green_func(rc, r, nval) Calculation of the Green function: nval Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rc Source radius double precision, intent(in) :: r Non-source radius integer, intent(in) :: nval Order number Return Value doubleprecision Calls proc~~green_func~~CallsGraph proc~green_func green_func proc~stdout stdout proc~green_func->proc~stdout Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~green_func~~CalledByGraph proc~green_func green_func proc~prod_vortex_structure prod_vortex_structure proc~prod_vortex_structure->proc~green_func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/green_func.html"},{"title":"undef_checker_2d – GVTD-HeCs","text":"public function undef_checker_2d(val, undef) Check missing value in \"val\" Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:,:) :: val Input double precision, intent(in) :: undef Undefined value Return Value logical Calls proc~~undef_checker_2d~~CallsGraph proc~undef_checker_2d undef_checker_2d proc~undef_checker_1d undef_checker_1d proc~undef_checker_2d->proc~undef_checker_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~undef_checker_2d~~CalledByGraph proc~undef_checker_2d undef_checker_2d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~undef_checker_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~undef_checker_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/undef_checker_2d.html"},{"title":"undef_checker_1d – GVTD-HeCs","text":"public function undef_checker_1d(val, undef) Check missing value in \"val\" Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:) :: val Input double precision, intent(in) :: undef Undefined value Return Value logical Called by proc~~undef_checker_1d~~CalledByGraph proc~undef_checker_1d undef_checker_1d proc~undef_checker_2d undef_checker_2d proc~undef_checker_2d->proc~undef_checker_1d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~undef_checker_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~undef_checker_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/undef_checker_1d.html"},{"title":"prod_vortex_structure – GVTD-HeCs","text":"public subroutine prod_vortex_structure(r, t, rmax, vmax, c1u, c2u, Vt, Vr, Vt_pert, Vr_pert, Vt_pert_ang, Vr_pert_ang, ropt, dopt, Vt_0, Vr_0, Uxm, Vym) Producing vortex structure with rmax, vmax, and umax Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) azimuthal angle [rad] double precision, intent(in) :: rmax radius of maximum tangential wind speed [m] double precision, intent(in) :: vmax maximum tangential wind speed [m s-1] double precision, intent(in) :: c1u coefficient 1 for radial wind [s-1] double precision, intent(in) :: c2u coefficient 2 for radial wind [s-1] double precision, intent(out) :: Vt (size(r),size(t)) Profile of tangential wind double precision, intent(out) :: Vr (size(r),size(t)) Profile of radial wind double precision, intent(in), optional :: Vt_pert (:) perturbations of tangential wind [m s-1] double precision, intent(in), optional :: Vr_pert (:) perturbations of radial wind [m s-1] double precision, intent(in), optional :: Vt_pert_ang (:) angles of tangential wind [rad] double precision, intent(in), optional :: Vr_pert_ang (:) angles of radial wind [rad] logical, intent(in), optional :: ropt option for radial variation of perturbation Vt and Vr logical, intent(in), optional :: dopt option for divergent components of perturbation Vt and Vr double precision, intent(out), optional :: Vt_0 (size(r)) Radial profile of axisymmetric Vt [m s-1] double precision, intent(out), optional :: Vr_0 (size(r)) Radial profile of axisymmetric Vr [m s-1] double precision, intent(out), optional :: Uxm (2) Azimuthal averaged X-wind of wavenumber-1 component [m s-1] double precision, intent(out), optional :: Vym (2) Azimuthal averaged Y-wind of wavenumber-1 component [m s-1] Calls proc~~prod_vortex_structure~~CallsGraph proc~prod_vortex_structure prod_vortex_structure proc~green_func green_func proc~prod_vortex_structure->proc~green_func dcos dcos proc~prod_vortex_structure->dcos dsin dsin proc~prod_vortex_structure->dsin proc~line_integral line_integral proc~prod_vortex_structure->proc~line_integral proc~stdout stdout proc~green_func->proc~stdout Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prod_vortex_structure.html"},{"title":"prod_vortex_structure_L06 – GVTD-HeCs","text":"public subroutine prod_vortex_structure_L06(r, t, rmax, zmax, epsr, Vt_pert_ang, Vt, Vr) Producing vortex structure with rmax, vmax, and umax in Lee et al. (2006) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) azimuthal angle [rad] double precision, intent(in) :: rmax radius of maximum tangential wind speed [m] double precision, intent(in) :: zmax constant vorticity in the eye [s-1] double precision, intent(in) :: epsr distance of epsilon for WN2 [m] double precision, intent(in) :: Vt_pert_ang angles of tangential wind [rad] double precision, intent(out) :: Vt (size(r),size(t)) Profile of tangential wind double precision, intent(out) :: Vr (size(r),size(t)) Profile of radial wind Calls proc~~prod_vortex_structure_l06~~CallsGraph proc~prod_vortex_structure_l06 prod_vortex_structure_L06 dcos dcos proc~prod_vortex_structure_l06->dcos dsin dsin proc~prod_vortex_structure_l06->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/prod_vortex_structure_l06.html"},{"title":"conv_VtVr2VxVy – GVTD-HeCs","text":"public subroutine conv_VtVr2VxVy(r, t, Vt, Vr, Vx, Vy, undef) Convert Vt and Vr to Vx and Vy on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(in) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(out) :: Vx (size(r),size(t)) X-component of wind on R-T coordinates double precision, intent(out) :: Vy (size(r),size(t)) Y-component of wind on R-T coordinates double precision, intent(in), optional :: undef Undefined value Calls proc~~conv_vtvr2vxvy~~CallsGraph proc~conv_vtvr2vxvy conv_VtVr2VxVy dcos dcos proc~conv_vtvr2vxvy->dcos dsin dsin proc~conv_vtvr2vxvy->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/conv_vtvr2vxvy.html"},{"title":"conv_VxVy2VtVr – GVTD-HeCs","text":"public subroutine conv_VxVy2VtVr(r, t, Vx, Vy, Vt, Vr, undef) Convert Vx and Vy to Vr and Vt on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: Vx (size(r),size(t)) X-component of wind on R-T coordinates double precision, intent(in) :: Vy (size(r),size(t)) Y-component of wind on R-T coordinates double precision, intent(out) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(out) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(in), optional :: undef Undefined value Calls proc~~conv_vxvy2vtvr~~CallsGraph proc~conv_vxvy2vtvr conv_VxVy2VtVr dcos dcos proc~conv_vxvy2vtvr->dcos dsin dsin proc~conv_vxvy2vtvr->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/conv_vxvy2vtvr.html"},{"title":"proj_VxVy2Vraxy – GVTD-HeCs","text":"public subroutine proj_VxVy2Vraxy(x, y, rax, ray, Vx, Vy, Vraxy, undef) Calculate Vx and Vy to Vd along with radar beams on X-Y coodinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: y (:) Y-coordinate double precision, intent(in) :: rax X-coodinate of radar location double precision, intent(in) :: ray Y-coodinate of radar location double precision, intent(in) :: Vx (size(x),size(y)) X-component of wind on X-Y coordinates double precision, intent(in) :: Vy (size(x),size(y)) Y-component of wind on X-Y coordinates double precision, intent(out) :: Vraxy (size(x),size(y)) velocity along with beam on X-Y coordinates double precision, intent(in), optional :: undef Undefined value Contents None","tags":"","loc":"proc/proj_vxvy2vraxy.html"},{"title":"proj_VtVr2Vrart – GVTD-HeCs","text":"public subroutine proj_VtVr2Vrart(r, t, td, Vt, Vr, Vra, undef) Convert Vt and Vr to Vx and Vy on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle on R-T coordinate [rad] double precision, intent(in) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(in) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(out) :: Vra (size(r),size(t)) Velocity along beam on R-T coordinates double precision, intent(in), optional :: undef undefined value Calls proc~~proj_vtvr2vrart~~CallsGraph proc~proj_vtvr2vrart proj_VtVr2Vrart dsin dsin proc~proj_vtvr2vrart->dsin dcos dcos proc~proj_vtvr2vrart->dcos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/proj_vtvr2vrart.html"},{"title":"div_curl_2d – GVTD-HeCs","text":"public subroutine div_curl_2d(r, t, ur, vt, divr, curl, undef) Calculation of rotation and divergence from radial and tangential winds divr = curl = Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) angle [rad] double precision, intent(in) :: ur (size(r),size(t)) Ur [m/s] double precision, intent(in) :: vt (size(r),size(t)) Vt [m/s] double precision, intent(out) :: divr (size(r),size(t)) divergence [1/s] double precision, intent(out) :: curl (size(r),size(t)) rotation [1/s] double precision, intent(in), optional :: undef Undefined value Contents None","tags":"","loc":"proc/div_curl_2d.html"},{"title":"conv_d2r_1d – GVTD-HeCs","text":"public subroutine conv_d2r_1d(ival, oval) Convert double to real Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:) Input real, intent(out) :: oval (size(ival)) Output Contents None","tags":"","loc":"proc/conv_d2r_1d.html"},{"title":"conv_d2r_2d – GVTD-HeCs","text":"public subroutine conv_d2r_2d(ival, oval) Convert double to real Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:,:) Input real, intent(out) :: oval (size(ival,1),size(ival,2)) Output Contents None","tags":"","loc":"proc/conv_d2r_2d.html"},{"title":"sum_1d – GVTD-HeCs","text":"public subroutine sum_1d(val, res, undef) Calculation of sum for 1D variable Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val (:) input double precision, intent(out) :: res output double precision, intent(in), optional :: undef Contents None","tags":"","loc":"proc/sum_1d.html"},{"title":"add_2d – GVTD-HeCs","text":"public subroutine add_2d(ioval, ival, undef) add ival Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: ioval (:,:) Base value double precision, intent(in) :: ival (size(ioval,1),size(ioval,2)) added double precision, intent(in), optional :: undef Undefined value Contents None","tags":"","loc":"proc/add_2d.html"},{"title":"subst_2d – GVTD-HeCs","text":"public subroutine subst_2d(ioval, ival, undef) subtract ival Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: ioval (:,:) Base value double precision, intent(in) :: ival (size(ioval,1),size(ioval,2)) Subtracted double precision, intent(in), optional :: undef Undefined value Contents None","tags":"","loc":"proc/subst_2d.html"},{"title":"subst_2d_r – GVTD-HeCs","text":"public subroutine subst_2d_r(ioval, ival, undef) subtract ival Arguments Type Intent Optional Attributes Name real, intent(inout) :: ioval (:,:) Base value real, intent(in) :: ival (size(ioval,1),size(ioval,2)) Subtracted value real, intent(in), optional :: undef Undefined value Contents None","tags":"","loc":"proc/subst_2d_r.html"},{"title":"rearrange_3d_2d – GVTD-HeCs","text":"public subroutine rearrange_3d_2d(val3d, val2d) Rearrange 3d variable to 2d variable (k,i,j -> i*j,k) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val3d (:,:,:) Input double precision, intent(out) :: val2d (size(val3d,2)*size(val3d,3),size(val3d,1)) Output Contents None","tags":"","loc":"proc/rearrange_3d_2d.html"},{"title":"rearrange_2d_1d – GVTD-HeCs","text":"public subroutine rearrange_2d_1d(val2d, val1d) Rearrange 2d variable to 1d variable (i,j -> i*j) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val2d (:,:) Input double precision, intent(out) :: val1d (size(val2d,1)*size(val2d,2)) Output Contents None","tags":"","loc":"proc/rearrange_2d_1d.html"},{"title":"display_2valdiff_max – GVTD-HeCs","text":"public subroutine display_2valdiff_max(val1, val2, undef, cout) Display the maximum of the difference between val1 and val2 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val1 (:,:) Input 1 double precision, intent(in) :: val2 (size(val1,1),size(val1,2)) Input 2 double precision, intent(in), optional :: undef Undefined value character, intent(out), optional :: cout Maximum value by character Contents None","tags":"","loc":"proc/display_2valdiff_max.html"},{"title":"stdout – GVTD-HeCs","text":"public subroutine stdout(message, routine_name, mtype) Standard output for message Arguments Type Intent Optional Attributes Name character, intent(in) :: message output message character, intent(in) :: routine_name called routine name integer, intent(in) :: mtype message type\n0: message, -1: error, 1: warning Called by proc~~stdout~~CalledByGraph proc~stdout stdout proc~green_func green_func proc~green_func->proc~stdout proc~retrieve_velocity_gbvtd Retrieve_velocity_GBVTD proc~retrieve_velocity_gbvtd->proc~stdout proc~calc_psid calc_psid proc~retrieve_velocity_gbvtd->proc~calc_psid proc~calc_psid->proc~stdout proc~retrieve_velocity2_gvtdx Retrieve_velocity2_GVTDX proc~retrieve_velocity2_gvtdx->proc~stdout proc~retrieve_velocity_gvtd Retrieve_velocity_GVTD proc~retrieve_velocity_gvtd->proc~stdout proc~retrieve_velocity_gvtdx Retrieve_velocity_GVTDX proc~retrieve_velocity_gvtdx->proc~stdout proc~prod_vortex_structure prod_vortex_structure proc~prod_vortex_structure->proc~green_func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/stdout.html"},{"title":"fp_gauss – GVTD-HeCs","text":"public subroutine fp_gauss(c, d, x) Gauss-Jordan method with fully pivotting (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: c (size(d),size(d)) Square matrix (array is the first elements) double precision, intent(in) :: d (:) Vector double precision, intent(inout) :: x (size(d)) Vector for unknown variables Called by proc~~fp_gauss~~CalledByGraph proc~fp_gauss fp_gauss proc~fp_invert_mat fp_invert_mat proc~fp_invert_mat->proc~fp_gauss proc~retrieve_velocity_gbvtd Retrieve_velocity_GBVTD proc~retrieve_velocity_gbvtd->proc~fp_gauss proc~retrieve_velocity2_gvtdx Retrieve_velocity2_GVTDX proc~retrieve_velocity2_gvtdx->proc~fp_gauss proc~retrieve_velocity_gvtd Retrieve_velocity_GVTD proc~retrieve_velocity_gvtd->proc~fp_gauss proc~retrieve_velocity_gvtdx Retrieve_velocity_GVTDX proc~retrieve_velocity_gvtdx->proc~fp_gauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fp_gauss.html"},{"title":"fp_invert_mat – GVTD-HeCs","text":"public subroutine fp_invert_mat(ax, xx) Calculate the inverse \"xx\" for the matrix \"ax\" (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ax (:,:) Input matrix double precision, intent(inout) :: xx (size(ax,1),size(ax,2)) Inverse Calls proc~~fp_invert_mat~~CallsGraph proc~fp_invert_mat fp_invert_mat proc~fp_gauss fp_gauss proc~fp_invert_mat->proc~fp_gauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fp_invert_mat.html"},{"title":"tangent_conv_scal – GVTD-HeCs","text":"public subroutine tangent_conv_scal(x, y, xc, yc, u, r, theta, v, undef, undefg, stdopt) Convert the Cartesian grid to polar grid with the origin of\n the storm center (from STPK)\nThe procedure: \n(1) Define the given polar grid (r-theta) on the Cartesian grid\n(2) Search the 4 nearest points on the Cartesian grid (x-y) for each polar grid point\n(3) Performing the bilinear interpolation of the 4 values defined on the\n    Cartesian grid to the polar grid. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate on the Cartesian grid double precision, intent(in) :: y (:) Y-coordinate on the Cartesian grid double precision, intent(in) :: xc X-component of the storm center double precision, intent(in) :: yc Y-component of the storm center double precision, intent(in) :: u (size(x),size(y)) Values defined on the Cartesian grid double precision, intent(in) :: r (:) R-coordinate on the polar grid with the origin (xc, yc). double precision, intent(in) :: theta (:) theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision, intent(out) :: v (size(r),size(theta)) Values converted to the polar grid double precision, intent(in), optional :: undef Missing value for the outside of the polar grid area (default: -999.0) double precision, intent(in), optional :: undefg Missing value for the inside of the polar grid area (default: -999.0) logical, intent(in), optional :: stdopt Display debug messages.\n(default: .false. == No display) Calls proc~~tangent_conv_scal~~CallsGraph proc~tangent_conv_scal tangent_conv_scal proc~rt_2_xy rt_2_xy proc~tangent_conv_scal->proc~rt_2_xy proc~interpo_search_2d interpo_search_2d proc~tangent_conv_scal->proc~interpo_search_2d proc~interpolation_2d interpolation_2d proc~tangent_conv_scal->proc~interpolation_2d proc~undef_checker_2d undef_checker_2d proc~tangent_conv_scal->proc~undef_checker_2d dcos dcos proc~rt_2_xy->dcos dsin dsin proc~rt_2_xy->dsin proc~interpo_search_1d interpo_search_1d proc~interpo_search_2d->proc~interpo_search_1d proc~interpolation_1d interpolation_1d proc~interpolation_2d->proc~interpolation_1d proc~undef_checker_1d undef_checker_1d proc~undef_checker_2d->proc~undef_checker_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tangent_conv_scal.html"},{"title":"cart_conv_scal – GVTD-HeCs","text":"public subroutine cart_conv_scal(r, theta, v, x, y, xc, yc, u, undef, undefg, stdopt) Convert polar grid with the origin of the storm center to \n the Cartesian grid (from STPK)\nThe procedure: \n(1) Define the given Cartesian grid (x-y) on the polar grid\n(2) Search the 4 nearest points on the polar grid for each Cartesian grid point\n(3) Performing the bilinear interpolation of the 4 values defined on the\n    polar grid to the Cartesian grid. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate on the polar grid with the origin (xc, yc). double precision, intent(in) :: theta (:) theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision, intent(in) :: v (size(r),size(theta)) Values defined on the polar grid double precision, intent(in) :: x (:) X-coordinate on the Cartesian grid double precision, intent(in) :: y (:) Y-coordinate on the Cartesian grid double precision, intent(in) :: xc X-component of the storm center double precision, intent(in) :: yc Y-component of the storm center double precision, intent(out) :: u (size(x),size(y)) Values converted to the Cartesian grid double precision, intent(in), optional :: undef Missing value for the outside of the Cartesian grid area (default: -999.0) double precision, intent(in), optional :: undefg Missing value for the inside of the Cartesian grid area (default: -999.0) logical, intent(in), optional :: stdopt Display debug messages.\n(default: .false. == No display) Calls proc~~cart_conv_scal~~CallsGraph proc~cart_conv_scal cart_conv_scal proc~xy_2_rt xy_2_rt proc~cart_conv_scal->proc~xy_2_rt proc~interpo_search_2d interpo_search_2d proc~cart_conv_scal->proc~interpo_search_2d proc~interpolation_2d interpolation_2d proc~cart_conv_scal->proc~interpolation_2d proc~undef_checker_2d undef_checker_2d proc~cart_conv_scal->proc~undef_checker_2d datan datan proc~xy_2_rt->datan proc~interpo_search_1d interpo_search_1d proc~interpo_search_2d->proc~interpo_search_1d proc~interpolation_1d interpolation_1d proc~interpolation_2d->proc~interpolation_1d proc~undef_checker_1d undef_checker_1d proc~undef_checker_2d->proc~undef_checker_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cart_conv_scal.html"},{"title":"interpo_search_2d – GVTD-HeCs","text":"public subroutine interpo_search_2d(x, y, pointx, pointy, i, j, undeff, stdopt) Floor function for the real grid points (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: y (:) Y-coordinate double precision, intent(in) :: pointx The X point in real double precision, intent(in) :: pointy The Y point in real integer, intent(out) :: i floor(pointx) integer, intent(out) :: j floor(pointy) integer, intent(in), optional :: undeff In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j\n(default = 0) logical, intent(in), optional :: stdopt Display debug messages\n(default = .false. = Not display) Calls proc~~interpo_search_2d~~CallsGraph proc~interpo_search_2d interpo_search_2d proc~interpo_search_1d interpo_search_1d proc~interpo_search_2d->proc~interpo_search_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpo_search_2d~~CalledByGraph proc~interpo_search_2d interpo_search_2d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~interpo_search_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~interpo_search_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpo_search_2d.html"},{"title":"interpo_search_1d – GVTD-HeCs","text":"public subroutine interpo_search_1d(x, point, i, undeff, stdopt) Floor function for the real grid points (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: point The X point in real integer, intent(out) :: i floor(pointx) integer, intent(in), optional :: undeff In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j\n(default = 0) logical, intent(in), optional :: stdopt Display debug messages\n(default = .false. = Not display) Called by proc~~interpo_search_1d~~CalledByGraph proc~interpo_search_1d interpo_search_1d proc~interpo_search_2d interpo_search_2d proc~interpo_search_2d->proc~interpo_search_1d proc~retrieve_velocity2_gvtdx Retrieve_velocity2_GVTDX proc~retrieve_velocity2_gvtdx->proc~interpo_search_1d proc~retrieve_velocity_gvtdx Retrieve_velocity_GVTDX proc~retrieve_velocity_gvtdx->proc~interpo_search_1d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~interpo_search_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~interpo_search_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpo_search_1d.html"},{"title":"xy_2_rt – GVTD-HeCs","text":"public subroutine xy_2_rt(x, y, xc, yc, r, t) Convert the Cartesian (x-y) grid to the polar (r-t) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x X-coordinate [m] double precision, intent(in) :: y Y-coordinate [m] double precision, intent(in) :: xc X-coordinate of the center on the polar grid double precision, intent(in) :: yc Y-coordinate of the center on the polar grid double precision, intent(out) :: r Radius [m] double precision, intent(out) :: t Angle [rad] Calls proc~~xy_2_rt~~CallsGraph proc~xy_2_rt xy_2_rt datan datan proc~xy_2_rt->datan Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~xy_2_rt~~CalledByGraph proc~xy_2_rt xy_2_rt proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~xy_2_rt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xy_2_rt.html"},{"title":"rt_2_xy – GVTD-HeCs","text":"public subroutine rt_2_xy(r, t, x, y) Convert the polar grid (r-t) to the Cartesian (x-y) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r Radius [m] double precision, intent(in) :: t Angle [rad] double precision, intent(out) :: x X-coordinate [m] double precision, intent(out) :: y Y-coordinate [m] Calls proc~~rt_2_xy~~CallsGraph proc~rt_2_xy rt_2_xy dcos dcos proc~rt_2_xy->dcos dsin dsin proc~rt_2_xy->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rt_2_xy~~CalledByGraph proc~rt_2_xy rt_2_xy proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~rt_2_xy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rt_2_xy.html"},{"title":"interpolation_2d – GVTD-HeCs","text":"public subroutine interpolation_2d(x, y, z, point, val) Perform bilinear interpolation to the \"point\" on the Cartesian (x-y) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (2) The nearest west and east points for \"point\" double precision, intent(in) :: y (2) The nearest south and north points for \"point\" double precision, intent(in) :: z (2,2) Values defined at (x,y).\nz(1,1) at x(1), y(1)\nz(1,2) at x(1), y(2)\nz(2,1) at x(2), y(1)\nz(2,2) at x(2), y(2) double precision, intent(in) :: point (2) The target point for the interpolation double precision, intent(out) :: val Interpolated value Calls proc~~interpolation_2d~~CallsGraph proc~interpolation_2d interpolation_2d proc~interpolation_1d interpolation_1d proc~interpolation_2d->proc~interpolation_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpolation_2d~~CalledByGraph proc~interpolation_2d interpolation_2d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~interpolation_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~interpolation_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolation_2d.html"},{"title":"interpolation_1d – GVTD-HeCs","text":"public subroutine interpolation_1d(x, y, point, val) Perform linear interpolation to the \"point\" on the Cartesian (x) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (2) The nearest west and east points for \"point\" double precision, intent(in) :: y (2) Values defined at x.\ny(1) at x(1)\ny(2) at x(2) double precision, intent(in) :: point The target point for the interpolation double precision, intent(out) :: val Interpolated value Called by proc~~interpolation_1d~~CalledByGraph proc~interpolation_1d interpolation_1d proc~interpolation_2d interpolation_2d proc~interpolation_2d->proc~interpolation_1d proc~tangent_conv_scal tangent_conv_scal proc~tangent_conv_scal->proc~interpolation_2d proc~cart_conv_scal cart_conv_scal proc~cart_conv_scal->proc~interpolation_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpolation_1d.html"},{"title":"max_val_1d – GVTD-HeCs","text":"public subroutine max_val_1d(var, mamv, undef) Get the max value (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var (:) Searched array double precision, intent(inout) :: mamv Max value in var double precision, intent(in), optional :: undef undefined value Contents None","tags":"","loc":"proc/max_val_1d.html"},{"title":"stand_devi – GVTD-HeCs","text":"public subroutine stand_devi(x, true_val, anor, undef) Calculate RMSE of x for the \"true_val\" (from STPK) Definition: RMSE Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) sampling data double precision, intent(in) :: true_val reference data double precision, intent(out) :: anor RMSE double precision, intent(in), optional :: undef missing value Contents None","tags":"","loc":"proc/stand_devi.html"},{"title":"matrix_sum – GVTD-HeCs","text":"public function matrix_sum(aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:) Matrix A1 double precision, intent(in) :: akj (size(aij)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij)) Undefined flag at each sampling point Return Value doubleprecision Contents None","tags":"","loc":"proc/matrix_sum~2.html"},{"title":"Retrieve_velocity_GBVTD – GVTD-HeCs","text":"public subroutine Retrieve_velocity_GBVTD(nasym, r, t, td, Vd, Un, Vn, RadTC, VT, VR, VT0, VR0, VTSn, VTCn, undef) Solve unknown variables and return wind velocity on R-T coordinates\n  based on the GBVTD technique. ------------------------------------------------------ [relationship between r and rh] -- ------------------------------------------------------ i-1    i    i+1 ...|-- --|-- --|... : r(1:size(r)) = velocity radii Arguments Type Intent Optional Attributes Name integer, intent(in) :: nasym wave number for asymmetric tangential wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VTSn (nasym,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VTCn (nasym,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd Calls proc~~retrieve_velocity_gbvtd~~CallsGraph proc~retrieve_velocity_gbvtd Retrieve_velocity_GBVTD proc~stdout stdout proc~retrieve_velocity_gbvtd->proc~stdout proc~calc_psid calc_psid proc~retrieve_velocity_gbvtd->proc~calc_psid proc~check_max check_max proc~retrieve_velocity_gbvtd->proc~check_max proc~fp_gauss fp_gauss proc~retrieve_velocity_gbvtd->proc~fp_gauss proc~calc_psid->proc~stdout dsin dsin proc~calc_psid->dsin datan2 datan2 proc~calc_psid->datan2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/retrieve_velocity_gbvtd.html"},{"title":"calc_psid – GVTD-HeCs","text":"public subroutine calc_psid(rtc, r, theta, thetad, psid) Calculate the nonlinear angle psid at a centain radius From the geometry, --(1) --(2) From Eq. (2), --(3) From Eqs. (1) and (3), Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rtc Distance from the radar to TC center [m] double precision, intent(in) :: r Radius [m] double precision, intent(in) :: theta (:) azimuthal angle [deg] double precision, intent(in) :: thetad (size(theta)) Azimuthal angle for radar [rad] double precision, intent(out) :: psid (size(theta)) Nonlinear angle [rad] Calls proc~~calc_psid~~CallsGraph proc~calc_psid calc_psid proc~stdout stdout proc~calc_psid->proc~stdout dsin dsin proc~calc_psid->dsin datan2 datan2 proc~calc_psid->datan2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_psid~~CalledByGraph proc~calc_psid calc_psid proc~retrieve_velocity_gbvtd Retrieve_velocity_GBVTD proc~retrieve_velocity_gbvtd->proc~calc_psid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_psid.html"},{"title":"check_max – GVTD-HeCs","text":"public subroutine check_max(ival, mx_val) Check maximum value in each element of the matrix \"a\" Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:) Matrix A double precision, intent(out) :: mx_val Max value in A Called by proc~~check_max~~CalledByGraph proc~check_max check_max proc~retrieve_velocity_gbvtd Retrieve_velocity_GBVTD proc~retrieve_velocity_gbvtd->proc~check_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_max.html"},{"title":"dot_prod – GVTD-HeCs","text":"public function dot_prod(v1, v2) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: v1 (:) double precision, intent(in) :: v2 (size(v1)) Return Value doubleprecision Contents None","tags":"","loc":"proc/dot_prod~2.html"},{"title":"matrix_sum – GVTD-HeCs","text":"public function matrix_sum(aij, akj, undeflag) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:,:) double precision, intent(in) :: akj (size(aij,1),size(aij,2)) logical, intent(in), optional :: undeflag (size(aij,1),size(aij,2)) Return Value doubleprecision Contents None","tags":"","loc":"proc/matrix_sum~4.html"},{"title":"Retrieve_velocity2_GVTDX – GVTD-HeCs","text":"public subroutine Retrieve_velocity2_GVTDX(nrot, ndiv, r, t, rh, td, rdiv, Vd, Un, Vn, RadTC, VT, VR, VRT0, VDR0, VRTn, VRRn, VDTm, VDRm, undef, phin, zetan, VRT0_GVTD, VDR0_GVTD, VRTns, VRTnc, VRRns, VRRnc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrot integer, intent(in) :: ndiv double precision, intent(in) :: r (:) double precision, intent(in) :: t (:) double precision, intent(in) :: rh (size(r)+1) double precision, intent(in) :: td (size(r),size(t)) double precision, intent(in) :: rdiv (:) double precision, intent(inout) :: Vd (size(r),size(t)) double precision, intent(in) :: Un (2) double precision, intent(in) :: Vn (2) double precision, intent(in) :: RadTC double precision, intent(out) :: VT (size(r),size(t)) double precision, intent(out) :: VR (size(r),size(t)) double precision, intent(out) :: VRT0 (size(r),size(t)) double precision, intent(out) :: VDR0 (size(r),size(t)) double precision, intent(out) :: VRTn (nrot,size(r),size(t)) double precision, intent(out) :: VRRn (nrot,size(r),size(t)) double precision, intent(out) :: VDTm (ndiv,size(r),size(t)) double precision, intent(out) :: VDRm (ndiv,size(r),size(t)) double precision, intent(in), optional :: undef double precision, intent(out), optional :: phin (nrot,size(r),size(t)) double precision, intent(out), optional :: zetan (nrot,size(r),size(t)) double precision, intent(out), optional :: VRT0_GVTD (size(r),size(t)) double precision, intent(out), optional :: VDR0_GVTD (size(r),size(t)) double precision, intent(out), optional :: VRTns (nrot,size(r),size(t)) double precision, intent(out), optional :: VRTnc (nrot,size(r),size(t)) double precision, intent(out), optional :: VRRns (nrot,size(r),size(t)) double precision, intent(out), optional :: VRRnc (nrot,size(r),size(t)) Calls proc~~retrieve_velocity2_gvtdx~~CallsGraph proc~retrieve_velocity2_gvtdx Retrieve_velocity2_GVTDX proc~stdout stdout proc~retrieve_velocity2_gvtdx->proc~stdout dcos dcos proc~retrieve_velocity2_gvtdx->dcos proc~interpo_search_1d interpo_search_1d proc~retrieve_velocity2_gvtdx->proc~interpo_search_1d proc~fp_gauss fp_gauss proc~retrieve_velocity2_gvtdx->proc~fp_gauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/retrieve_velocity2_gvtdx.html"},{"title":"dot_prod – GVTD-HeCs","text":"public function dot_prod(v1, v2) Calculate inner product of two vectors Arguments Type Intent Optional Attributes Name double precision, intent(in) :: v1 (:) Vector 1 double precision, intent(in) :: v2 (size(v1)) Return Value doubleprecision Contents None","tags":"","loc":"proc/dot_prod.html"},{"title":"matrix_sum – GVTD-HeCs","text":"public function matrix_sum(aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:,:) Matrix A1 double precision, intent(in) :: akj (size(aij,1),size(aij,2)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij,1),size(aij,2)) Undefined flag at each sampling point Return Value doubleprecision Contents None","tags":"","loc":"proc/matrix_sum~3.html"},{"title":"Retrieve_velocity_GVTDX – GVTD-HeCs","text":"public subroutine Retrieve_velocity_GVTDX(nrot, ndiv, r, t, rh, td, rdiv, Vd, Un, Vn, RadTC, VT, VR, VRT0, VDR0, VRTn, VRRn, VDTm, VDRm, undef, phin, zetan, VRT0_GVTD, VDR0_GVTD, VRTns, VRTnc, VRRns, VRRnc) Solve unknown variables and return wind velocity on R-T coordinates. ------------------------------------------------------- -- [relationship between r and rh] -- ------------------------------------------------------- --   i-1    i    i+1 -- ...|-- --|-- --|... : r(1:size(r)) = velocity radii -- |-- --|-- --|-- --| : rh(1,size(r)+1) = potential radii --i-1    i    i+1   i+2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrot wave number for rotating wind integer, intent(in) :: ndiv wave number for divergent wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: rh (size(r)+1) radial coordinate on which Phi (staggered for Vd) is defined [m] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(in) :: rdiv (:) radial coordinate on which Dc (staggered for Vd) is defined [m] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VRT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VDR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VRTn (nrot,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VRRn (nrot,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(out) :: VDTm (ndiv,size(r),size(t)) retrieved tangential component of divergent wind [m s-1] double precision, intent(out) :: VDRm (ndiv,size(r),size(t)) retrieved radial component of divergent wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd double precision, intent(out), optional :: phin (nrot,size(r),size(t)) retrieved stream function [m2 s-1] double precision, intent(out), optional :: zetan (nrot,size(r),size(t)) retrieved vorticity [s-1] double precision, intent(out), optional :: VRT0_GVTD (size(r),size(t)) retrieved axisymmetric radial component of pseudo-GVTD tangential wind [m s-1] double precision, intent(out), optional :: VDR0_GVTD (size(r),size(t)) retrieved axisymmetric tangential component of pseudo-GVTD tangential wind [m s-1] double precision, intent(out), optional :: VRTns (nrot,size(r),size(t)) Sine component of retrieved asymmetric radial wind [m s-1] double precision, intent(out), optional :: VRTnc (nrot,size(r),size(t)) Cosine component of retrieved asymmetric radial wind [m s-1] double precision, intent(out), optional :: VRRns (nrot,size(r),size(t)) Sine component of retrieved asymmetric tangential wind [m s-1] double precision, intent(out), optional :: VRRnc (nrot,size(r),size(t)) Cosine component of retrieved asymmetric tangential wind [m s-1] Calls proc~~retrieve_velocity_gvtdx~~CallsGraph proc~retrieve_velocity_gvtdx Retrieve_velocity_GVTDX proc~stdout stdout proc~retrieve_velocity_gvtdx->proc~stdout dcos dcos proc~retrieve_velocity_gvtdx->dcos proc~interpo_search_1d interpo_search_1d proc~retrieve_velocity_gvtdx->proc~interpo_search_1d proc~fp_gauss fp_gauss proc~retrieve_velocity_gvtdx->proc~fp_gauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/retrieve_velocity_gvtdx.html"},{"title":"GVTD_main – GVTD-HeCs","text":"Uses GVTDX_sub module~~gvtd_main~~UsesGraph module~gvtd_main GVTD_main module~gvtdx_sub GVTDX_sub module~gvtd_main->module~gvtdx_sub Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions matrix_sum Subroutines Retrieve_velocity_GVTD Functions public function matrix_sum (aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:) Matrix A1 double precision, intent(in) :: akj (size(aij)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij)) Undefined flag at each sampling point Return Value doubleprecision Subroutines public subroutine Retrieve_velocity_GVTD (nasym, r, t, td, Vd, Un, Vn, RadTC, VT, VR, VT0, VR0, VTSn, VTCn, undef) Solve unknown variables and return wind velocity on R-T coordinates\n  based on the GVTD technique. ------------------------------------------------------ [relationship between r and rh] -- ------------------------------------------------------ i-1    i    i+1 ...|-- --|-- --|... : r(1:size(r)) = velocity radii Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nasym wave number for asymmetric tangential wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VTSn (nasym,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VTCn (nasym,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd","tags":"","loc":"module/gvtd_main.html"},{"title":"GVTDX_sub – GVTD-HeCs","text":"Sub module for GVTDX procedures. Used by module~~gvtdx_sub~~UsedByGraph module~gvtdx_sub GVTDX_sub module~gvtd_main GVTD_main module~gvtd_main->module~gvtdx_sub module~gbvtd_main GBVTD_main module~gbvtd_main->module~gvtdx_sub module~gvtdx_main GVTDX_main module~gvtdx_main->module~gvtdx_sub module~gvtdx_main2 GVTDX_main2 module~gvtdx_main2->module~gvtdx_sub Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi img pi_dp img_cdp Functions line_integral green_func undef_checker_2d undef_checker_1d Subroutines prod_vortex_structure prod_vortex_structure_L06 conv_VtVr2VxVy conv_VxVy2VtVr proj_VxVy2Vraxy proj_VtVr2Vrart div_curl_2d conv_d2r_1d conv_d2r_2d sum_1d add_2d subst_2d subst_2d_r rearrange_3d_2d rearrange_2d_1d display_2valdiff_max stdout fp_gauss fp_invert_mat tangent_conv_scal cart_conv_scal interpo_search_2d interpo_search_1d xy_2_rt rt_2_xy interpolation_2d interpolation_1d max_val_1d stand_devi Variables Type Visibility Attributes Name Initial real, public, parameter :: pi = 3.14159265e0 Pi for real complex, public, parameter :: img = (0.0, 1.0) Imaginary unit for real double precision, public, parameter :: pi_dp = 3.14159265358979d0 Pi for double complex(kind=kind(0d0)), public, parameter :: img_cdp = (0.0d0, 1.0d0) Imaginary unit for double Functions public function line_integral (nr, rdh, gkrr, div_r, undef) Calculate a line integral (actually, sum for arguments) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr Radial grid number double precision, intent(in) :: rdh (nr+1) R-coordinate [m] double precision, intent(in) :: gkrr (nr+1) Green function double precision, intent(in) :: div_r (nr+1) Integral of gkrr double precision, intent(in), optional :: undef Undefined value Return Value doubleprecision public function green_func (rc, r, nval) Calculation of the Green function: nval Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rc Source radius double precision, intent(in) :: r Non-source radius integer, intent(in) :: nval Order number Return Value doubleprecision public function undef_checker_2d (val, undef) Check missing value in \"val\" Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:,:) :: val Input double precision, intent(in) :: undef Undefined value Return Value logical public function undef_checker_1d (val, undef) Check missing value in \"val\" Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:) :: val Input double precision, intent(in) :: undef Undefined value Return Value logical Subroutines public subroutine prod_vortex_structure (r, t, rmax, vmax, c1u, c2u, Vt, Vr, Vt_pert, Vr_pert, Vt_pert_ang, Vr_pert_ang, ropt, dopt, Vt_0, Vr_0, Uxm, Vym) Producing vortex structure with rmax, vmax, and umax Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) azimuthal angle [rad] double precision, intent(in) :: rmax radius of maximum tangential wind speed [m] double precision, intent(in) :: vmax maximum tangential wind speed [m s-1] double precision, intent(in) :: c1u coefficient 1 for radial wind [s-1] double precision, intent(in) :: c2u coefficient 2 for radial wind [s-1] double precision, intent(out) :: Vt (size(r),size(t)) Profile of tangential wind double precision, intent(out) :: Vr (size(r),size(t)) Profile of radial wind double precision, intent(in), optional :: Vt_pert (:) perturbations of tangential wind [m s-1] double precision, intent(in), optional :: Vr_pert (:) perturbations of radial wind [m s-1] double precision, intent(in), optional :: Vt_pert_ang (:) angles of tangential wind [rad] double precision, intent(in), optional :: Vr_pert_ang (:) angles of radial wind [rad] logical, intent(in), optional :: ropt option for radial variation of perturbation Vt and Vr logical, intent(in), optional :: dopt option for divergent components of perturbation Vt and Vr double precision, intent(out), optional :: Vt_0 (size(r)) Radial profile of axisymmetric Vt [m s-1] double precision, intent(out), optional :: Vr_0 (size(r)) Radial profile of axisymmetric Vr [m s-1] double precision, intent(out), optional :: Uxm (2) Azimuthal averaged X-wind of wavenumber-1 component [m s-1] double precision, intent(out), optional :: Vym (2) Azimuthal averaged Y-wind of wavenumber-1 component [m s-1] public subroutine prod_vortex_structure_L06 (r, t, rmax, zmax, epsr, Vt_pert_ang, Vt, Vr) Producing vortex structure with rmax, vmax, and umax in Lee et al. (2006) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) azimuthal angle [rad] double precision, intent(in) :: rmax radius of maximum tangential wind speed [m] double precision, intent(in) :: zmax constant vorticity in the eye [s-1] double precision, intent(in) :: epsr distance of epsilon for WN2 [m] double precision, intent(in) :: Vt_pert_ang angles of tangential wind [rad] double precision, intent(out) :: Vt (size(r),size(t)) Profile of tangential wind double precision, intent(out) :: Vr (size(r),size(t)) Profile of radial wind public subroutine conv_VtVr2VxVy (r, t, Vt, Vr, Vx, Vy, undef) Convert Vt and Vr to Vx and Vy on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(in) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(out) :: Vx (size(r),size(t)) X-component of wind on R-T coordinates double precision, intent(out) :: Vy (size(r),size(t)) Y-component of wind on R-T coordinates double precision, intent(in), optional :: undef Undefined value public subroutine conv_VxVy2VtVr (r, t, Vx, Vy, Vt, Vr, undef) Convert Vx and Vy to Vr and Vt on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: Vx (size(r),size(t)) X-component of wind on R-T coordinates double precision, intent(in) :: Vy (size(r),size(t)) Y-component of wind on R-T coordinates double precision, intent(out) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(out) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(in), optional :: undef Undefined value public subroutine proj_VxVy2Vraxy (x, y, rax, ray, Vx, Vy, Vraxy, undef) Calculate Vx and Vy to Vd along with radar beams on X-Y coodinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: y (:) Y-coordinate double precision, intent(in) :: rax X-coodinate of radar location double precision, intent(in) :: ray Y-coodinate of radar location double precision, intent(in) :: Vx (size(x),size(y)) X-component of wind on X-Y coordinates double precision, intent(in) :: Vy (size(x),size(y)) Y-component of wind on X-Y coordinates double precision, intent(out) :: Vraxy (size(x),size(y)) velocity along with beam on X-Y coordinates double precision, intent(in), optional :: undef Undefined value public subroutine proj_VtVr2Vrart (r, t, td, Vt, Vr, Vra, undef) Convert Vt and Vr to Vx and Vy on R-T coordinates Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate [m] double precision, intent(in) :: t (:) T-coordinate [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle on R-T coordinate [rad] double precision, intent(in) :: Vt (size(r),size(t)) tangential wind component on R-T coordinates double precision, intent(in) :: Vr (size(r),size(t)) radial wind component on R-T coordinates double precision, intent(out) :: Vra (size(r),size(t)) Velocity along beam on R-T coordinates double precision, intent(in), optional :: undef undefined value public subroutine div_curl_2d (r, t, ur, vt, divr, curl, undef) Calculation of rotation and divergence from radial and tangential winds divr = curl = Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) radius [m] double precision, intent(in) :: t (:) angle [rad] double precision, intent(in) :: ur (size(r),size(t)) Ur [m/s] double precision, intent(in) :: vt (size(r),size(t)) Vt [m/s] double precision, intent(out) :: divr (size(r),size(t)) divergence [1/s] double precision, intent(out) :: curl (size(r),size(t)) rotation [1/s] double precision, intent(in), optional :: undef Undefined value public subroutine conv_d2r_1d (ival, oval) Convert double to real Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:) Input real, intent(out) :: oval (size(ival)) Output public subroutine conv_d2r_2d (ival, oval) Convert double to real Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:,:) Input real, intent(out) :: oval (size(ival,1),size(ival,2)) Output public subroutine sum_1d (val, res, undef) Calculation of sum for 1D variable Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val (:) input double precision, intent(out) :: res output double precision, intent(in), optional :: undef public subroutine add_2d (ioval, ival, undef) add ival Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: ioval (:,:) Base value double precision, intent(in) :: ival (size(ioval,1),size(ioval,2)) added double precision, intent(in), optional :: undef Undefined value public subroutine subst_2d (ioval, ival, undef) subtract ival Arguments Type Intent Optional Attributes Name double precision, intent(inout) :: ioval (:,:) Base value double precision, intent(in) :: ival (size(ioval,1),size(ioval,2)) Subtracted double precision, intent(in), optional :: undef Undefined value public subroutine subst_2d_r (ioval, ival, undef) subtract ival Arguments Type Intent Optional Attributes Name real, intent(inout) :: ioval (:,:) Base value real, intent(in) :: ival (size(ioval,1),size(ioval,2)) Subtracted value real, intent(in), optional :: undef Undefined value public subroutine rearrange_3d_2d (val3d, val2d) Rearrange 3d variable to 2d variable (k,i,j -> i*j,k) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val3d (:,:,:) Input double precision, intent(out) :: val2d (size(val3d,2)*size(val3d,3),size(val3d,1)) Output public subroutine rearrange_2d_1d (val2d, val1d) Rearrange 2d variable to 1d variable (i,j -> i*j) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val2d (:,:) Input double precision, intent(out) :: val1d (size(val2d,1)*size(val2d,2)) Output public subroutine display_2valdiff_max (val1, val2, undef, cout) Display the maximum of the difference between val1 and val2 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: val1 (:,:) Input 1 double precision, intent(in) :: val2 (size(val1,1),size(val1,2)) Input 2 double precision, intent(in), optional :: undef Undefined value character, intent(out), optional :: cout Maximum value by character public subroutine stdout (message, routine_name, mtype) Standard output for message Arguments Type Intent Optional Attributes Name character, intent(in) :: message output message character, intent(in) :: routine_name called routine name integer, intent(in) :: mtype message type\n0: message, -1: error, 1: warning public subroutine fp_gauss (c, d, x) Gauss-Jordan method with fully pivotting (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: c (size(d),size(d)) Square matrix (array is the first elements) double precision, intent(in) :: d (:) Vector double precision, intent(inout) :: x (size(d)) Vector for unknown variables public subroutine fp_invert_mat (ax, xx) Calculate the inverse \"xx\" for the matrix \"ax\" (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ax (:,:) Input matrix double precision, intent(inout) :: xx (size(ax,1),size(ax,2)) Inverse public subroutine tangent_conv_scal (x, y, xc, yc, u, r, theta, v, undef, undefg, stdopt) Convert the Cartesian grid to polar grid with the origin of\n the storm center (from STPK)\nThe procedure: \n(1) Define the given polar grid (r-theta) on the Cartesian grid\n(2) Search the 4 nearest points on the Cartesian grid (x-y) for each polar grid point\n(3) Performing the bilinear interpolation of the 4 values defined on the\n    Cartesian grid to the polar grid. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate on the Cartesian grid double precision, intent(in) :: y (:) Y-coordinate on the Cartesian grid double precision, intent(in) :: xc X-component of the storm center double precision, intent(in) :: yc Y-component of the storm center double precision, intent(in) :: u (size(x),size(y)) Values defined on the Cartesian grid double precision, intent(in) :: r (:) R-coordinate on the polar grid with the origin (xc, yc). double precision, intent(in) :: theta (:) theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision, intent(out) :: v (size(r),size(theta)) Values converted to the polar grid double precision, intent(in), optional :: undef Missing value for the outside of the polar grid area (default: -999.0) double precision, intent(in), optional :: undefg Missing value for the inside of the polar grid area (default: -999.0) logical, intent(in), optional :: stdopt Display debug messages.\n(default: .false. == No display) public subroutine cart_conv_scal (r, theta, v, x, y, xc, yc, u, undef, undefg, stdopt) Convert polar grid with the origin of the storm center to \n the Cartesian grid (from STPK)\nThe procedure: \n(1) Define the given Cartesian grid (x-y) on the polar grid\n(2) Search the 4 nearest points on the polar grid for each Cartesian grid point\n(3) Performing the bilinear interpolation of the 4 values defined on the\n    polar grid to the Cartesian grid. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r (:) R-coordinate on the polar grid with the origin (xc, yc). double precision, intent(in) :: theta (:) theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision, intent(in) :: v (size(r),size(theta)) Values defined on the polar grid double precision, intent(in) :: x (:) X-coordinate on the Cartesian grid double precision, intent(in) :: y (:) Y-coordinate on the Cartesian grid double precision, intent(in) :: xc X-component of the storm center double precision, intent(in) :: yc Y-component of the storm center double precision, intent(out) :: u (size(x),size(y)) Values converted to the Cartesian grid double precision, intent(in), optional :: undef Missing value for the outside of the Cartesian grid area (default: -999.0) double precision, intent(in), optional :: undefg Missing value for the inside of the Cartesian grid area (default: -999.0) logical, intent(in), optional :: stdopt Display debug messages.\n(default: .false. == No display) public subroutine interpo_search_2d (x, y, pointx, pointy, i, j, undeff, stdopt) Floor function for the real grid points (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: y (:) Y-coordinate double precision, intent(in) :: pointx The X point in real double precision, intent(in) :: pointy The Y point in real integer, intent(out) :: i floor(pointx) integer, intent(out) :: j floor(pointy) integer, intent(in), optional :: undeff In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j\n(default = 0) logical, intent(in), optional :: stdopt Display debug messages\n(default = .false. = Not display) public subroutine interpo_search_1d (x, point, i, undeff, stdopt) Floor function for the real grid points (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) X-coordinate double precision, intent(in) :: point The X point in real integer, intent(out) :: i floor(pointx) integer, intent(in), optional :: undeff In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j\n(default = 0) logical, intent(in), optional :: stdopt Display debug messages\n(default = .false. = Not display) public subroutine xy_2_rt (x, y, xc, yc, r, t) Convert the Cartesian (x-y) grid to the polar (r-t) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x X-coordinate [m] double precision, intent(in) :: y Y-coordinate [m] double precision, intent(in) :: xc X-coordinate of the center on the polar grid double precision, intent(in) :: yc Y-coordinate of the center on the polar grid double precision, intent(out) :: r Radius [m] double precision, intent(out) :: t Angle [rad] public subroutine rt_2_xy (r, t, x, y) Convert the polar grid (r-t) to the Cartesian (x-y) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: r Radius [m] double precision, intent(in) :: t Angle [rad] double precision, intent(out) :: x X-coordinate [m] double precision, intent(out) :: y Y-coordinate [m] public subroutine interpolation_2d (x, y, z, point, val) Perform bilinear interpolation to the \"point\" on the Cartesian (x-y) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (2) The nearest west and east points for \"point\" double precision, intent(in) :: y (2) The nearest south and north points for \"point\" double precision, intent(in) :: z (2,2) Values defined at (x,y).\nz(1,1) at x(1), y(1)\nz(1,2) at x(1), y(2)\nz(2,1) at x(2), y(1)\nz(2,2) at x(2), y(2) double precision, intent(in) :: point (2) The target point for the interpolation double precision, intent(out) :: val Interpolated value public subroutine interpolation_1d (x, y, point, val) Perform linear interpolation to the \"point\" on the Cartesian (x) grid (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (2) The nearest west and east points for \"point\" double precision, intent(in) :: y (2) Values defined at x.\ny(1) at x(1)\ny(2) at x(2) double precision, intent(in) :: point The target point for the interpolation double precision, intent(out) :: val Interpolated value public subroutine max_val_1d (var, mamv, undef) Get the max value (from STPK) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var (:) Searched array double precision, intent(inout) :: mamv Max value in var double precision, intent(in), optional :: undef undefined value public subroutine stand_devi (x, true_val, anor, undef) Calculate RMSE of x for the \"true_val\" (from STPK) Definition: RMSE Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x (:) sampling data double precision, intent(in) :: true_val reference data double precision, intent(out) :: anor RMSE double precision, intent(in), optional :: undef missing value","tags":"","loc":"module/gvtdx_sub.html"},{"title":"GBVTD_main – GVTD-HeCs","text":"The main module of GBVTD based on Lee et al. (1999, MWR) Uses GVTDX_sub module~~gbvtd_main~~UsesGraph module~gbvtd_main GBVTD_main module~gvtdx_sub GVTDX_sub module~gbvtd_main->module~gvtdx_sub Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions matrix_sum Subroutines Retrieve_velocity_GBVTD calc_psid check_max Functions public function matrix_sum (aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:) Matrix A1 double precision, intent(in) :: akj (size(aij)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij)) Undefined flag at each sampling point Return Value doubleprecision Subroutines public subroutine Retrieve_velocity_GBVTD (nasym, r, t, td, Vd, Un, Vn, RadTC, VT, VR, VT0, VR0, VTSn, VTCn, undef) Solve unknown variables and return wind velocity on R-T coordinates\n  based on the GBVTD technique. ------------------------------------------------------ [relationship between r and rh] -- ------------------------------------------------------ i-1    i    i+1 ...|-- --|-- --|... : r(1:size(r)) = velocity radii Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nasym wave number for asymmetric tangential wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VTSn (nasym,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VTCn (nasym,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd public subroutine calc_psid (rtc, r, theta, thetad, psid) Calculate the nonlinear angle psid at a centain radius From the geometry, --(1) --(2) From Eq. (2), --(3) From Eqs. (1) and (3), Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rtc Distance from the radar to TC center [m] double precision, intent(in) :: r Radius [m] double precision, intent(in) :: theta (:) azimuthal angle [deg] double precision, intent(in) :: thetad (size(theta)) Azimuthal angle for radar [rad] double precision, intent(out) :: psid (size(theta)) Nonlinear angle [rad] public subroutine check_max (ival, mx_val) Check maximum value in each element of the matrix \"a\" Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ival (:) Matrix A double precision, intent(out) :: mx_val Max value in A","tags":"","loc":"module/gbvtd_main.html"},{"title":"GVTDX_main2 – GVTD-HeCs","text":"Uses GVTDX_sub module~~gvtdx_main2~~UsesGraph module~gvtdx_main2 GVTDX_main2 module~gvtdx_sub GVTDX_sub module~gvtdx_main2->module~gvtdx_sub Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions dot_prod matrix_sum Subroutines Retrieve_velocity2_GVTDX Functions public function dot_prod (v1, v2) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: v1 (:) double precision, intent(in) :: v2 (size(v1)) Return Value doubleprecision public function matrix_sum (aij, akj, undeflag) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:,:) double precision, intent(in) :: akj (size(aij,1),size(aij,2)) logical, intent(in), optional :: undeflag (size(aij,1),size(aij,2)) Return Value doubleprecision Subroutines public subroutine Retrieve_velocity2_GVTDX (nrot, ndiv, r, t, rh, td, rdiv, Vd, Un, Vn, RadTC, VT, VR, VRT0, VDR0, VRTn, VRRn, VDTm, VDRm, undef, phin, zetan, VRT0_GVTD, VDR0_GVTD, VRTns, VRTnc, VRRns, VRRnc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrot integer, intent(in) :: ndiv double precision, intent(in) :: r (:) double precision, intent(in) :: t (:) double precision, intent(in) :: rh (size(r)+1) double precision, intent(in) :: td (size(r),size(t)) double precision, intent(in) :: rdiv (:) double precision, intent(inout) :: Vd (size(r),size(t)) double precision, intent(in) :: Un (2) double precision, intent(in) :: Vn (2) double precision, intent(in) :: RadTC double precision, intent(out) :: VT (size(r),size(t)) double precision, intent(out) :: VR (size(r),size(t)) double precision, intent(out) :: VRT0 (size(r),size(t)) double precision, intent(out) :: VDR0 (size(r),size(t)) double precision, intent(out) :: VRTn (nrot,size(r),size(t)) double precision, intent(out) :: VRRn (nrot,size(r),size(t)) double precision, intent(out) :: VDTm (ndiv,size(r),size(t)) double precision, intent(out) :: VDRm (ndiv,size(r),size(t)) double precision, intent(in), optional :: undef double precision, intent(out), optional :: phin (nrot,size(r),size(t)) double precision, intent(out), optional :: zetan (nrot,size(r),size(t)) double precision, intent(out), optional :: VRT0_GVTD (size(r),size(t)) double precision, intent(out), optional :: VDR0_GVTD (size(r),size(t)) double precision, intent(out), optional :: VRTns (nrot,size(r),size(t)) double precision, intent(out), optional :: VRTnc (nrot,size(r),size(t)) double precision, intent(out), optional :: VRRns (nrot,size(r),size(t)) double precision, intent(out), optional :: VRRnc (nrot,size(r),size(t))","tags":"","loc":"module/gvtdx_main2.html"},{"title":"GVTDX_main – GVTD-HeCs","text":"The main module of GVTD-X Uses GVTDX_sub module~~gvtdx_main~~UsesGraph module~gvtdx_main GVTDX_main module~gvtdx_sub GVTDX_sub module~gvtdx_main->module~gvtdx_sub Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions dot_prod matrix_sum Subroutines Retrieve_velocity_GVTDX Functions public function dot_prod (v1, v2) Calculate inner product of two vectors Arguments Type Intent Optional Attributes Name double precision, intent(in) :: v1 (:) Vector 1 double precision, intent(in) :: v2 (size(v1)) Return Value doubleprecision public function matrix_sum (aij, akj, undeflag) Calculate product for a component in a matrix Arguments Type Intent Optional Attributes Name double precision, intent(in) :: aij (:,:) Matrix A1 double precision, intent(in) :: akj (size(aij,1),size(aij,2)) Matrix A2 logical, intent(in), optional :: undeflag (size(aij,1),size(aij,2)) Undefined flag at each sampling point Return Value doubleprecision Subroutines public subroutine Retrieve_velocity_GVTDX (nrot, ndiv, r, t, rh, td, rdiv, Vd, Un, Vn, RadTC, VT, VR, VRT0, VDR0, VRTn, VRRn, VDTm, VDRm, undef, phin, zetan, VRT0_GVTD, VDR0_GVTD, VRTns, VRTnc, VRRns, VRRnc) Solve unknown variables and return wind velocity on R-T coordinates. ------------------------------------------------------- -- [relationship between r and rh] -- ------------------------------------------------------- --   i-1    i    i+1 -- ...|-- --|-- --|... : r(1:size(r)) = velocity radii -- |-- --|-- --|-- --| : rh(1,size(r)+1) = potential radii --i-1    i    i+1   i+2 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrot wave number for rotating wind integer, intent(in) :: ndiv wave number for divergent wind double precision, intent(in) :: r (:) radial coordinate on which Vd is defined [m] double precision, intent(in) :: t (:) azimuthal coordinate on which Vd is defined [rad] double precision, intent(in) :: rh (size(r)+1) radial coordinate on which Phi (staggered for Vd) is defined [m] double precision, intent(in) :: td (size(r),size(t)) radar azimuthal angle defined at Vd(r,t) [rad] double precision, intent(in) :: rdiv (:) radial coordinate on which Dc (staggered for Vd) is defined [m] double precision, intent(inout) :: Vd (size(r),size(t)) Doppler velocity defined on r-t [m s-1] double precision, intent(in) :: Un (2) Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: Vn (2) Normal component to radar in environmental wind, defined on r-t [m s-1] double precision, intent(in) :: RadTC Distance from radar to TC center [m] double precision, intent(out) :: VT (size(r),size(t)) retrieved total tangential wind [m s-1] double precision, intent(out) :: VR (size(r),size(t)) retrieved total radial wind [m s-1] double precision, intent(out) :: VRT0 (size(r),size(t)) retrieved axisymmetric radial component of rotating wind [m s-1] double precision, intent(out) :: VDR0 (size(r),size(t)) retrieved axisymmetric tangential component of divergent wind [m s-1] double precision, intent(out) :: VRTn (nrot,size(r),size(t)) retrieved tangential component of rotating wind [m s-1] double precision, intent(out) :: VRRn (nrot,size(r),size(t)) retrieved radial component of rotating wind [m s-1] double precision, intent(out) :: VDTm (ndiv,size(r),size(t)) retrieved tangential component of divergent wind [m s-1] double precision, intent(out) :: VDRm (ndiv,size(r),size(t)) retrieved radial component of divergent wind [m s-1] double precision, intent(in), optional :: undef undefined value for Vd double precision, intent(out), optional :: phin (nrot,size(r),size(t)) retrieved stream function [m2 s-1] double precision, intent(out), optional :: zetan (nrot,size(r),size(t)) retrieved vorticity [s-1] double precision, intent(out), optional :: VRT0_GVTD (size(r),size(t)) retrieved axisymmetric radial component of pseudo-GVTD tangential wind [m s-1] double precision, intent(out), optional :: VDR0_GVTD (size(r),size(t)) retrieved axisymmetric tangential component of pseudo-GVTD tangential wind [m s-1] double precision, intent(out), optional :: VRTns (nrot,size(r),size(t)) Sine component of retrieved asymmetric radial wind [m s-1] double precision, intent(out), optional :: VRTnc (nrot,size(r),size(t)) Cosine component of retrieved asymmetric radial wind [m s-1] double precision, intent(out), optional :: VRRns (nrot,size(r),size(t)) Sine component of retrieved asymmetric tangential wind [m s-1] double precision, intent(out), optional :: VRRnc (nrot,size(r),size(t)) Cosine component of retrieved asymmetric tangential wind [m s-1]","tags":"","loc":"module/gvtdx_main.html"},{"title":"gvtd_main_mod.f90 – GVTD-HeCs","text":"This file depends on sourcefile~~gvtd_main_mod.f90~~EfferentGraph sourcefile~gvtd_main_mod.f90 gvtd_main_mod.f90 sourcefile~sub_mod.f90 sub_mod.f90 sourcefile~gvtd_main_mod.f90->sourcefile~sub_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GVTD_main Source Code gvtd_main_mod.f90 Source Code module GVTD_main use GVTDX_sub implicit none public :: Retrieve_velocity_GVTD private :: calc_fkj private :: calc_fkj2akp private :: calc_fkjVd2bk private :: set_xk2variables private :: calc_AB2VT private :: calc_Vn2Vtot private :: check_zero private :: check_undef_grid private :: set_undef_value contains subroutine Retrieve_velocity_GVTD ( nasym , r , t , td , Vd , Un , Vn , RadTC , & & VT , VR , VT0 , VR0 , VTSn , VTCn , undef ) !!  Solve unknown variables and return wind velocity on R-T coordinates !!  based on the GVTD technique. <br> !!------------------------------------------------------ <br> !!  [relationship between r and rh] -- <br> !!------------------------------------------------------ <br> !!    i-1    i    i+1 <br> !!  ...|-- --|-- --|... : r(1:size(r)) = velocity radii <br> !!------------------------------------------------------ implicit none !-- input/output integer , intent ( in ) :: nasym !! wave number for asymmetric tangential wind double precision , intent ( in ) :: r (:) !! radial coordinate on which Vd is defined [m] double precision , intent ( in ) :: t (:) !! azimuthal coordinate on which Vd is defined [rad] double precision , intent ( in ) :: td ( size ( r ), size ( t )) !! radar azimuthal angle defined at Vd(r,t) [rad] double precision , intent ( inout ) :: Vd ( size ( r ), size ( t )) !! Doppler velocity defined on r-t [m s-1] double precision , intent ( in ) :: Un ( 2 ) !! Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: Vn ( 2 ) !! Normal component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: RadTC !! Distance from radar to TC center [m] double precision , intent ( out ) :: VT ( size ( r ), size ( t )) !! retrieved total tangential wind [m s-1] double precision , intent ( out ) :: VR ( size ( r ), size ( t )) !! retrieved total radial wind [m s-1] double precision , intent ( out ) :: VT0 ( size ( r ), size ( t )) !! retrieved axisymmetric radial component of rotating wind [m s-1] double precision , intent ( out ) :: VR0 ( size ( r ), size ( t )) !! retrieved axisymmetric tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VTSn ( nasym , size ( r ), size ( t )) !! retrieved tangential component of rotating wind [m s-1] double precision , intent ( out ) :: VTCn ( nasym , size ( r ), size ( t )) !! retrieved radial component of rotating wind [m s-1] double precision , intent ( in ), optional :: undef !! undefined value for Vd !-- internal variables integer :: i , j , k , p , cstat ! dummy indexes integer :: nr , nt ! array numbers for r and t, respectively integer :: nk ! array number of a_k double precision , allocatable , dimension (:,:) :: x_k ! unknown vector for retrieved coefficients double precision , allocatable , dimension (:,:) :: b_k ! known vector given by observed values double precision , allocatable , dimension (:,:,:) :: a_kp ! coefficient matrix for x_k double precision , allocatable , dimension (:,:,:) :: f_kj ! a_kp = sum_{j}(f_kj * f_pj) double precision , allocatable , dimension (:) :: Vd_A0 ! Results for wavenumber-0 of Vd double precision , allocatable , dimension (:,:) :: Vd_AC ! Results for cosine components of Vd double precision , allocatable , dimension (:,:) :: Vd_BS ! Results for sine components of Vd double precision :: dundef , vmax , tmprho double precision , dimension ( size ( r )) :: r_n ! Nondimensional r double precision :: rtc_n ! Nondimensional RadTC double precision , dimension ( size ( r ), size ( t )) :: delta ! delta_ij logical , allocatable , dimension (:,:) :: undeflag ! Flag for Vd grid with undef !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"Retrieve_velocity_GVTD\" , 0 ) nr = size ( r ) nt = size ( t ) vmax = 5 0.0d0 if ( present ( undef )) then dundef = undef else dundef =- 1.0d35 end if VT = dundef VR = dundef VT0 = dundef VR0 = dundef VTSn = dundef VTCn = dundef delta = dundef !-- Check retrieved asymmetric wave number if ( nasym < 0 ) then call stdout ( \"nasym is greater equal to 0. stop.\" , \"Retrieve_velocity_GVTD\" , - 1 ) stop end if nk = 1 + 2 * ( nasym + 1 ) !-- Normalized r r_n = r / r ( nr ) rtc_n = RadTC / r ( nr ) !-- Calculate delta_ij !$omp parallel default(shared) !$omp do schedule(runtime) private(i,j,tmprho) do j = 1 , nt do i = 1 , nr if ( rtc_n > 0.0d0 ) then tmprho = r_n ( i ) / rtc_n delta ( i , j ) = dsqrt ( tmprho ** 2 + 2.0d0 * tmprho * dcos ( t ( j )) + 1.0d0 ) end if end do end do !$omp end do !$omp end parallel !-- Allocate and initialize arrays ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( Vd_A0 ( ompnum ), stat = cstat ) allocate ( Vd_AC ( nasym + 1 , ompnum ), stat = cstat ) allocate ( Vd_BS ( nasym + 1 , ompnum ), stat = cstat ) allocate ( x_k ( nk , ompnum ), stat = cstat ) allocate ( b_k ( nk , ompnum ), stat = cstat ) allocate ( a_kp ( nk , nk , ompnum ), stat = cstat ) allocate ( f_kj ( nk , nt , ompnum ), stat = cstat ) allocate ( undeflag ( nr , nt ), stat = cstat ) undeflag = . false . call check_undef_grid ( Vd , dundef , undeflag ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"Retrieve_velocity_GVTD\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(i,omppe) do i = 1 , nr !$   omppe=OMP_GET_THREAD_NUM()+1 x_k ( 1 : nk , omppe ) = 0.0d0 b_k ( 1 : nk , omppe ) = 0.0d0 a_kp ( 1 : nk , 1 : nk , omppe ) = 0.0d0 f_kj ( 1 : nk , 1 : nt , omppe ) = 0.0d0 Vd_A0 ( omppe ) = 0.0d0 Vd_AC ( 1 : nasym + 1 , omppe ) = 0.0d0 Vd_BS ( 1 : nasym + 1 , omppe ) = 0.0d0 !-- Calculate f_kj call calc_fkj ( nasym , nk , t , f_kj ( 1 : nk , 1 : nt , omppe ), undeflag ( i , 1 : nt ) ) !-- Calculate b_k call calc_fkjVd2bk ( vmax , f_kj ( 1 : nk , 1 : nt , omppe ), Vd ( i , 1 : nt ), delta ( i , 1 : nt ), & & b_k ( 1 : nk , omppe ), undeflag ( i , 1 : nt ) ) !-- Calculate a_kp call calc_fkj2akp ( f_kj ( 1 : nk , 1 : nt , omppe ), a_kp ( 1 : nk , 1 : nk , omppe ), undeflag ( i , 1 : nt ) ) call check_zero ( a_kp ( 1 : nk , 1 : nk , omppe ) ) !-- Solve x_k !  call tri_gauss( a_kp, b_k, x_k ) !  call gausss( a_kp, b_k, x_k ) call fp_gauss ( a_kp ( 1 : nk , 1 : nk , omppe ), b_k ( 1 : nk , omppe ), x_k ( 1 : nk , omppe ) ) !-- Set each unknown variable from x_k call set_xk2variables ( nasym , nk , x_k ( 1 : nk , omppe ), Vd_A0 ( omppe ), & & Vd_AC ( 1 : nasym + 1 , omppe ), Vd_BS ( 1 : nasym + 1 , omppe ), & & undef = dundef ) !-- Calculate Vr and Vt components of rotating wind call calc_AB2VT ( nasym , vmax , r_n ( i ), t , rtc_n , Vd_A0 ( omppe ), & & Vd_AC ( 1 : nasym + 1 , omppe ), Vd_BS ( 1 : nasym + 1 , omppe ), & & VT0 ( i , 1 : nt ), VR0 ( i , 1 : nt ), VTSn ( 1 : nasym , i , 1 : nt ), VTCn ( 1 : nasym , i , 1 : nt ), undef = dundef ) end do !$omp end do !$omp end parallel !-- Calculate total retrieved Vr and Vt call calc_Vn2Vtot ( nasym , VT0 , VTSn , VTCn , VT ) VR = VR0 !-- Set undef in each output variable at undefined grids call set_undef_value ( undeflag , dundef , VT ) call set_undef_value ( undeflag , dundef , VR ) if ( nasym > 0 ) then do k = 1 , nasym call set_undef_value ( undeflag , dundef , VTSn ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VTCn ( k , 1 : nr , 1 : nt ) ) end do end if call stdout ( \"Finish procedure.\" , \"Retrieve_velocity_GVTD\" , 0 ) end subroutine Retrieve_velocity_GVTD subroutine calc_fkj ( nasym , nnk , theta , fkj , undeflag ) !! Calculate the coefficient matrix f_{kj} implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components integer , intent ( in ) :: nnk !! Matrix dimension for fkj double precision , intent ( in ) :: theta (:) ! Azimuthal angle [rad] double precision , intent ( out ) :: fkj ( nnk , size ( theta )) !! Coefficient matrix logical , intent ( in ) :: undeflag ( size ( theta )) !! Undefined flag at each sampling point !-- internal variables integer :: nmax , nnt , jj , kk , cstat double precision , dimension ( nasym + 1 , size ( theta )) :: sinen , cosinen call stdout ( \"Enter procedure.\" , \"calc_fkj\" , 0 ) nnt = size ( theta ) fkj = 0.0d0 nmax = nasym + 1 sinen = 0.0d0 cosinen = 0.0d0 if ( nnk /= 1 + 2 * ( nasym + 1 )) then call stdout ( \"nnk is not 1+2(nasym+1). stop.\" , \"calc_fkj\" , - 1 ) stop end if !-- Set fixed variables for R-T, in advance do jj = 1 , nnt do kk = 1 , nmax sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !-- Set coefficients for A0 at each (jj) fkj ( 1 , 1 : nnt ) = 1.0d0 !-- Set coefficients for A1 to An and B1 to Bn at each (jj) do jj = 1 , nnt do kk = 1 , nmax fkj ( 1 + kk , jj ) = cosinen ( kk , jj ) fkj ( 1 + nmax + kk , jj ) = sinen ( kk , jj ) end do end do call stdout ( \"Finish procedure.\" , \"calc_fkj\" , 0 ) end subroutine calc_fkj subroutine calc_fkj2akp ( fkj , akp , undeflag ) !! Calculate a_kp from f_kj implicit none double precision , intent ( in ) :: fkj (:,:) !! Coefficient matrix double precision , intent ( out ) :: akp ( size ( fkj , 1 ), size ( fkj , 1 )) !! Coefficient matrix in LSM logical , intent ( in ) :: undeflag ( size ( fkj , 2 )) !! Undefined flag at each sampling point integer :: nnk , nnj , jj , kk , ll , cstat call stdout ( \"Enter procedure.\" , \"calc_fkj2akp\" , 0 ) nnk = size ( fkj , 1 ) nnj = size ( fkj , 2 ) do ll = 1 , nnk do kk = ll , nnk akp ( kk , ll ) = matrix_sum ( fkj ( kk , 1 : nnj ), fkj ( ll , 1 : nnj ), & & undeflag ( 1 : nnj ) ) akp ( ll , kk ) = akp ( kk , ll ) end do end do call stdout ( \"Finish procedure.\" , \"calc_fkj2akp\" , 0 ) end subroutine calc_fkj2akp subroutine calc_fkjVd2bk ( vmax , fkj , Vdl , deltaij , bk , undeflag ) !! Calculate b_k from f_{k,j} and V_d implicit none double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: fkj (:,:) !! Coefficient matrix double precision , intent ( in ) :: Vdl ( size ( fkj , 2 )) !! Doppler velocity [m/s] double precision , intent ( in ) :: deltaij ( size ( fkj , 2 )) !! The geometric factor double precision , intent ( out ) :: bk ( size ( fkj , 1 )) !! Vector \\textbf{b}  logical , intent ( in ) :: undeflag ( size ( fkj , 2 )) !! Undefined flag at each sampling point integer :: nnk , nnj , jj , kk , ll , cstat double precision :: dVdl ( size ( fkj , 2 )) call stdout ( \"Enter procedure.\" , \"calc_fkjVd2bk\" , 0 ) nnk = size ( fkj , 1 ) nnj = size ( fkj , 2 ) do jj = 1 , nnj if ( undeflag ( jj ). eqv .. true .) then dVdl ( jj ) = Vdl ( jj ) else dVdl ( jj ) = deltaij ( jj ) * Vdl ( jj ) end if end do do kk = 1 , nnk bk ( kk ) = matrix_sum ( dVdl ( 1 : nnj ), fkj ( kk , 1 : nnj ), & & undeflag ( 1 : nnj ) ) / vmax end do call stdout ( \"Finish procedure.\" , \"calc_fkjVd2bk\" , 0 ) end subroutine calc_fkjVd2bk subroutine set_xk2variables ( nasym , nnk , xk , A0 , ACn , BSn , undef ) !! Set each unknown variable from x_k implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components integer , intent ( in ) :: nnk !! Matrix dimension for coefficient matrix A double precision , intent ( in ) :: xk ( nnk ) !! solved unknown variable vector double precision , intent ( out ) :: A0 !! Wavenumber-0 for Doppler velocity double precision , intent ( out ) :: ACn ( nasym + 1 ) !! Cosine conponents of Doppler velocity double precision , intent ( out ) :: BSn ( nasym + 1 ) !! Sine components of Doppler velocity double precision , intent ( in ), optional :: undef !! Undefined value integer :: kk call stdout ( \"Enter procedure.\" , \"set_xk2variables\" , 0 ) A0 = xk ( 1 ) do kk = 1 , nasym + 1 ACn ( kk ) = xk ( 1 + kk ) BSn ( kk ) = xk ( 1 + nasym + 1 + kk ) end do call stdout ( \"Finish procedure.\" , \"set_xk2variables\" , 0 ) end subroutine set_xk2variables subroutine calc_AB2VT ( nasym , vmax , rd , theta , rtc , A0 , An , Bn , & & VT0_rt , VR0_rt , VTSn_rt , VTCn_rt , undef ) !! Calculate tangential components of retrieved wind implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rd !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: rtc !! Normalized distance between the radar to vortex center [1] double precision , intent ( in ) :: A0 !! Wanvenumber-0 of Doppler velocity double precision , intent ( in ) :: An ( nasym + 1 ) !! Cosine components of Doppler velocity double precision , intent ( in ) :: Bn ( nasym + 1 ) !! Sine components of Doppler velocity double precision , intent ( out ) :: VT0_rt ( size ( psid )) !! Wavenumber-0 tangential wind double precision , intent ( out ) :: VR0_rt ( size ( psid )) !! Wavenumber-0 radial wind double precision , intent ( out ) :: VTSn_rt ( nasym , size ( psid )) !! Sine components of tangential wind [m/s] double precision , intent ( out ) :: VTCn_rt ( nasym , size ( psid )) !! Cosine components of tangential wind [m/s] double precision , intent ( in ), optional :: undef !! No use integer :: jj , kk , nnt , cstat double precision , dimension ( nasym , size ( theta )) :: cosinen , sinen double precision , dimension ( nasym ) :: VTSn_r , VTCn_r call stdout ( \"Enter procedure.\" , \"calc_AB2VT\" , 0 ) nnt = size ( theta ) do jj = 1 , nnt do kk = 1 , nasym cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) end do end do VT0_rt ( 1 : nnt ) = ( - Bn ( 1 ) - Bn ( 3 )) * vmax VR0_rt ( 1 : nnt ) = ( A0 + An ( 1 ) + An ( 2 ) + An ( 3 ) + An ( 4 )) / ( 1.0d0 + rd / rtc ) * vmax do kk = 1 , nasym VTSn_r ( kk ) = 2.0d0 * An ( kk + 1 ) VTCn_r ( kk ) =- 2.0d0 * Bn ( kk + 1 ) end do VTSn_r ( 1 ) = VTSn_r ( 1 ) + VTSn_r ( 3 ) VTCn_r ( 1 ) = VTCn_r ( 1 ) + VTCn_r ( 3 ) do jj = 1 , nnt do kk = 1 , nasym VTSn_rt ( kk , jj ) = VTSn_r ( kk ) * sinen ( kk , jj ) * vmax VTCn_rt ( kk , jj ) = VTCn_r ( kk ) * cosinen ( kk , jj ) * vmax end do end do call stdout ( \"Finish procedure.\" , \"calc_AB2VT\" , 0 ) end subroutine calc_AB2VT subroutine calc_Vn2Vtot ( nasym , V0 , VSn , VCn , Vtot , undef ) !! Calculate total wind from all wavenumbers implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components double precision , intent ( in ) :: V0 (:,:) !! Wavenumber-0 wind [m/s] double precision , intent ( in ) :: VSn ( nasym , size ( V0 , 1 ), size ( V0 , 2 )) !! Sine components of wnd [m/s] double precision , intent ( in ) :: VCn ( nasym , size ( V0 , 1 ), size ( V0 , 2 )) !! Cosine components of wind [m/s] double precision , intent ( inout ) :: Vtot ( size ( V0 , 1 ), size ( V0 , 2 )) !! Total wind [m/s] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , kk , nnr , nnt call stdout ( \"Enter procedure.\" , \"calc_Vn2Vtot\" , 0 ) nnr = size ( V0 , 1 ) nnt = size ( V0 , 2 ) Vtot = V0 if ( present ( undef )) then do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nasym if ( VSn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + VSn ( kk , ii , jj ) end if if ( VCn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + VCn ( kk , ii , jj ) end if end do end do end do else do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nasym Vtot ( ii , jj ) = Vtot ( ii , jj ) + VSn ( kk , ii , jj ) + VCn ( kk , ii , jj ) end do end do end do end if call stdout ( \"Finish procedure.\" , \"calc_VSn2Vtot\" , 0 ) end subroutine calc_Vn2Vtot double precision function matrix_sum ( aij , akj , undeflag ) !! Calculate product for a component in a matrix implicit none double precision , intent ( in ) :: aij (:) !! Matrix A1 double precision , intent ( in ) :: akj ( size ( aij )) !! Matrix A2 logical , intent ( in ), optional :: undeflag ( size ( aij )) !! Undefined flag at each sampling point integer :: jj , nj double precision :: res nj = size ( aij ) res = 0.0d0 if ( present ( undeflag )) then do jj = 1 , nj if ( undeflag ( jj ). eqv .. false .) then res = res + aij ( jj ) * akj ( jj ) end if end do else do jj = 1 , nj res = res + aij ( jj ) * akj ( jj ) end do end if matrix_sum = res return end function matrix_sum subroutine check_zero ( a ) !! Check zero components in the matrix \"a\" implicit none double precision , intent ( in ) :: a (:,:) !! Matrix A integer :: ii , jj , nni , nnj logical :: res nni = size ( a , 1 ) nnj = size ( a , 2 ) do jj = 1 , nnj res = . false . do ii = 1 , nni if ( a ( ii , jj ) /= 0.0d0 ) then res = . true . exit end if end do if ( res . eqv .. false .) then write ( * , * ) \"Detect all zero\" , jj end if end do end subroutine check_zero subroutine check_undef_grid ( vval , undefv , undeflag ) !! Check undefined grids implicit none double precision , intent ( in ) :: vval (:,:) !! Grid value double precision , intent ( in ) :: undefv !! Undefined value logical , intent ( out ) :: undeflag ( size ( vval , 1 ), size ( vval , 2 )) ! Undefined flag integer :: ii , jj , nni , nnj nni = size ( vval , 1 ) nnj = size ( vval , 2 ) undeflag = . false . do jj = 1 , nnj do ii = 1 , nni if ( vval ( ii , jj ) == undefv ) then undeflag ( ii , jj ) = . true . end if end do end do end subroutine check_undef_grid subroutine set_undef_value ( undeflag , undefv , vval ) !! Set undef value (=\"undefv\") to val if undeflag == true. implicit none logical , intent ( in ) :: undeflag (:,:) !! Undefined flag at each sampling point double precision , intent ( in ) :: undefv !! Undefined value double precision , intent ( inout ) :: vval ( size ( undeflag , 1 ), size ( undeflag , 2 )) !! Original value at each sampling point integer :: ii , jj , nni , nnj nni = size ( undeflag , 1 ) nnj = size ( undeflag , 2 ) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then vval ( ii , jj ) = undefv end if end do end do end subroutine set_undef_value end module GVTD_main","tags":"","loc":"sourcefile/gvtd_main_mod.f90.html"},{"title":"sub_mod.f90 – GVTD-HeCs","text":"Files dependent on this one sourcefile~~sub_mod.f90~~AfferentGraph sourcefile~sub_mod.f90 sub_mod.f90 sourcefile~gvtd_main_mod.f90 gvtd_main_mod.f90 sourcefile~gvtd_main_mod.f90->sourcefile~sub_mod.f90 sourcefile~gvtdx_main_mod.f90 gvtdx_main_mod.f90 sourcefile~gvtdx_main_mod.f90->sourcefile~sub_mod.f90 sourcefile~gbvtd_main_mod.f90 gbvtd_main_mod.f90 sourcefile~gbvtd_main_mod.f90->sourcefile~sub_mod.f90 sourcefile~gvtdx_main_mod2.f90 gvtdx_main_mod2.f90 sourcefile~gvtdx_main_mod2.f90->sourcefile~sub_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GVTDX_sub Source Code sub_mod.f90 Source Code module GVTDX_sub !! Sub module for GVTDX procedures. implicit none real , parameter :: pi = 3.14159265e0 !! Pi for real complex , parameter :: img = ( 0.0 , 1.0 ) !! Imaginary unit for real double precision , parameter :: pi_dp = 3.14159265358979d0 !! Pi for double complex ( kind ( 0 d0 )), parameter :: img_cdp = ( 0.0d0 , 1.0d0 ) !! Imaginary unit for double contains !------------------------------------------ subroutine prod_vortex_structure ( r , t , rmax , vmax , c1u , c2u , & & Vt , Vr , Vt_pert , Vr_pert , Vt_pert_ang , Vr_pert_ang , & & ropt , dopt , Vt_0 , Vr_0 , Uxm , Vym ) !! Producing vortex structure with rmax, vmax, and umax implicit none double precision , intent ( in ) :: r (:) !! radius [m] double precision , intent ( in ) :: t (:) !! azimuthal angle [rad] double precision , intent ( in ) :: rmax !! radius of maximum tangential wind speed [m] double precision , intent ( in ) :: vmax !! maximum tangential wind speed [m s-1] double precision , intent ( in ) :: c1u !! coefficient 1 for radial wind [s-1] double precision , intent ( in ) :: c2u !! coefficient 2 for radial wind [s-1] double precision , intent ( out ) :: Vt ( size ( r ), size ( t )) !! Profile of tangential wind double precision , intent ( out ) :: Vr ( size ( r ), size ( t )) !! Profile of radial wind double precision , intent ( in ), optional :: Vt_pert (:) !! perturbations of tangential wind [m s-1] double precision , intent ( in ), optional :: Vr_pert (:) !! perturbations of radial wind [m s-1] double precision , intent ( in ), optional :: Vt_pert_ang (:) !! angles of tangential wind [rad] double precision , intent ( in ), optional :: Vr_pert_ang (:) !! angles of radial wind [rad] logical , intent ( in ), optional :: ropt !! option for radial variation of perturbation Vt and Vr logical , intent ( in ), optional :: dopt !! option for divergent components of perturbation Vt and Vr double precision , intent ( out ), optional :: Vt_0 ( size ( r )) !! Radial profile of axisymmetric Vt [m s-1] double precision , intent ( out ), optional :: Vr_0 ( size ( r )) !! Radial profile of axisymmetric Vr [m s-1] double precision , intent ( out ), optional :: Uxm ( 2 ) !! Azimuthal averaged X-wind of wavenumber-1 component [m s-1] double precision , intent ( out ), optional :: Vym ( 2 ) !! Azimuthal averaged Y-wind of wavenumber-1 component [m s-1] integer :: nr , nt , i , j , k , nvtp , nvrp , nvpmax double precision :: tmp_vtp1 , tmp_vrp1 , tmp_vtp2n , tmp_vrp2n , rad_coef , radp_coef , lin_coef , dr double precision :: tmp_vtp1_div , tmp_vrp1_div double precision :: umean ( 2 ), vmean ( 2 ) double precision :: r_inv ( size ( r )) double precision , allocatable , dimension (:,:) :: zetap , divp double precision , allocatable , dimension (:,:,:) :: gkrr , dgkrr logical rad_opt nr = size ( r ) nt = size ( t ) if ( present ( Vt_pert )) then nvtp = size ( Vt_pert ) else nvtp = 0 end if if ( present ( Vr_pert )) then nvrp = size ( Vr_pert ) else nvrp = 0 end if nvpmax = max ( nvtp , nvrp ) dr = r ( 2 ) - r ( 1 ) rad_opt = . false . if ( present ( ropt )) then rad_opt = ropt if ( nvpmax > 0 ) then allocate ( gkrr ( nvpmax , nr + 1 , nr + 1 )) allocate ( dgkrr ( nvpmax , nr + 1 , nr + 1 )) allocate ( zetap ( nvpmax , nr + 1 )) allocate ( divp ( nvpmax , nr + 1 )) gkrr = 0.0d0 dgkrr = 0.0d0 zetap = 0.0d0 divp = 0.0d0 do k = 1 , nvpmax do j = 1 , nr do i = 1 , nr if ( r ( i ) - 0.5d0 * dr < 0.0d0 ) then gkrr ( k , i , j ) = green_func ( 0.0d0 , r ( j ), k ) else gkrr ( k , i , j ) = green_func ( r ( i ) - 0.5d0 * dr , r ( j ), k ) end if end do end do do j = 1 , nr gkrr ( k , nr + 1 , j ) = green_func ( r ( nr ) + 0.5d0 * dr , r ( j ), k ) end do do i = 1 , nr gkrr ( k , i , nr + 1 ) = green_func ( r ( i ) + 0.5d0 * dr , r ( nr ) + dr , k ) end do do j = 1 , nr do i = 1 , nr + 1 dgkrr ( k , i , j ) = ( gkrr ( k , i , j + 1 ) - gkrr ( k , i , j )) / dr end do end do do i = 1 , nr !              if(r(i)<2.0d0*rmax)then if ( r ( i ) >= 0.1d0 * rmax . and . r ( i ) < 2.0d0 * rmax ) then zetap ( k , i ) = abs ( Vt_pert ( k )) / rmax end if if ( r ( i ) >= rmax . and . r ( i ) < 1.5d0 * rmax ) then divp ( k , i ) =- abs ( Vr_pert ( k )) / rmax end if end do end do end if end if do i = 1 , nr if ( r ( i ) /= 0.0d0 ) then r_inv ( i ) = 1.0d0 / r ( i ) else r_inv ( i ) = 0.0d0 end if end do do j = 1 , nt do i = 1 , nr tmp_vtp1 = 0.0d0 tmp_vrp1 = 0.0d0 tmp_vtp2n = 0.0d0 tmp_vrp2n = 0.0d0 tmp_vtp1_div = 0.0d0 tmp_vrp1_div = 0.0d0 if ( present ( Vt_pert )) then if ( rad_opt . eqv .. true .) then if ( nvtp > 1 ) then !                 do k=2,nvtp do k = 1 , nvtp lin_coef = line_integral ( nr - 1 , r , dgkrr ( k , 1 : nr , i ), zetap ( k , 1 : nr ) ) * dr tmp_vtp2n = tmp_vtp2n + ( - lin_coef * dcos ( dble ( k ) * ( t ( j ) + Vt_pert_ang ( k )))) end do end if else do k = 1 , nvtp tmp_vtp1 = tmp_vtp1 + Vt_pert ( k ) * dcos ( dble ( k ) * ( t ( j ) + Vt_pert_ang ( k ))) end do end if end if if ( present ( Vr_pert )) then if ( rad_opt . eqv .. true .) then if ( nvrp > 1 ) then !                 do k=2,nvrp do k = 1 , nvrp lin_coef = line_integral ( nr - 1 , r , gkrr ( k , 1 : nr , i ), zetap ( k , 1 : nr ) ) * dr tmp_vrp2n = tmp_vrp2n + ( - dble ( k ) * lin_coef * dsin ( dble ( k ) * ( t ( j ) + Vt_pert_ang ( k ))) * r_inv ( i )) ! same as Vt_pert_ang end do end if else do k = 1 , nvrp tmp_vrp1 = tmp_vrp1 + Vr_pert ( k ) * dcos ( dble ( k ) * ( t ( j ) + Vr_pert_ang ( k ))) end do end if end if if ( r ( i ) <= rmax ) then rad_coef = r ( i ) / rmax radp_coef = r ( i ) / rmax Vt ( i , j ) = vmax * rad_coef Vr ( i , j ) = c1u * dsqrt (( rmax - r ( i )) * r ( i )) Vr ( i , j ) = Vr ( i , j ) * 4.0 * 1.0e-3 ! 多分これが必要 [m] -> [km] else rad_coef = rmax * r_inv ( i ) if (( r ( i ) > rmax ). and .( r ( i ) <= 1.5d0 * rmax )) then radp_coef = 1.0d0 else radp_coef = rmax * r_inv ( i ) end if Vt ( i , j ) = vmax * rad_coef Vr ( i , j ) =- c2u * dsqrt ( r ( i ) - rmax ) * ( rmax * r_inv ( i )) Vr ( i , j ) = Vr ( i , j ) / dsqrt ( 100 0.0d0 ) ! 多分これが必要 [m] -> [km] end if if ( j == 1 ) then if ( present ( Vt_0 )) then Vt_0 ( i ) = Vt ( i , j ) end if if ( present ( Vr_0 )) then Vr_0 ( i ) = Vr ( i , j ) end if end if if ( rad_opt . eqv .. true .) then Vt ( i , j ) = Vt ( i , j ) + tmp_vtp1 * radp_coef + tmp_vtp2n Vr ( i , j ) = Vr ( i , j ) + tmp_vrp1 * radp_coef + tmp_vrp2n else Vt ( i , j ) = Vt ( i , j ) + tmp_vtp1 + tmp_vtp2n Vr ( i , j ) = Vr ( i , j ) + tmp_vrp1 + tmp_vrp2n end if end do end do if ( present ( ropt )) then if ( nvpmax > 0 ) then deallocate ( gkrr ) deallocate ( dgkrr ) deallocate ( zetap ) end if end if if ( present ( Uxm )) then umean ( 1 ) = 0.0d0 umean ( 2 ) = 0.0d0 do j = 1 , nt umean ( 1 ) = umean ( 1 ) + ( Vr ( 1 , j ) * dcos ( t ( j )) - Vt ( 1 , j ) * dsin ( t ( j ))) umean ( 2 ) = umean ( 2 ) + ( Vr ( nr , j ) * dcos ( t ( j )) - Vt ( nr , j ) * dsin ( t ( j ))) end do umean ( 1 ) = umean ( 1 ) / dble ( nt ) umean ( 2 ) = umean ( 2 ) / dble ( nt ) Uxm ( 1 : 2 ) = umean ( 1 : 2 ) end if if ( present ( Vym )) then vmean ( 1 ) = 0.0d0 vmean ( 2 ) = 0.0d0 do j = 1 , nt vmean ( 1 ) = vmean ( 1 ) + ( Vr ( 1 , j ) * dsin ( t ( j )) + Vt ( 1 , j ) * dcos ( t ( j ))) vmean ( 2 ) = vmean ( 2 ) + ( Vr ( nr , j ) * dsin ( t ( j )) + Vt ( nr , j ) * dcos ( t ( j ))) end do vmean ( 1 ) = vmean ( 1 ) / dble ( nt ) vmean ( 2 ) = vmean ( 2 ) / dble ( nt ) Vym ( 1 : 2 ) = vmean ( 1 : 2 ) end if end subroutine prod_vortex_structure subroutine prod_vortex_structure_L06 ( r , t , rmax , zmax , epsr , Vt_pert_ang , Vt , Vr ) !! Producing vortex structure with rmax, vmax, and umax in Lee et al. (2006) implicit none double precision , intent ( in ) :: r (:) !! radius [m] double precision , intent ( in ) :: t (:) !! azimuthal angle [rad] double precision , intent ( in ) :: rmax !! radius of maximum tangential wind speed [m] double precision , intent ( in ) :: zmax !! constant vorticity in the eye [s-1] double precision , intent ( in ) :: epsr !! distance of epsilon for WN2 [m] double precision , intent ( in ) :: Vt_pert_ang !! angles of tangential wind [rad] double precision , intent ( out ) :: Vt ( size ( r ), size ( t )) !! Profile of tangential wind double precision , intent ( out ) :: Vr ( size ( r ), size ( t )) !! Profile of radial wind integer :: nr , nt , i , j double precision :: R_ell nr = size ( r ) nt = size ( t ) do j = 1 , nt R_ell = rmax + epsr * dcos ( 2.0d0 * t ( j ) + Vt_pert_ang ) do i = 1 , nr if ( r ( i ) <= R_ell ) then Vt ( i , j ) = 0.5d0 * zmax * r ( i ) * ( 1.0d0 + ( epsr / rmax ) * dcos ( 2.0d0 * t ( j ) + Vt_pert_ang )) Vr ( i , j ) = 0.5d0 * zmax * r ( i ) * (( epsr / rmax ) * dsin ( 2.0d0 * t ( j ) + Vt_pert_ang )) else Vt ( i , j ) = 0.5d0 * zmax * ( rmax ** 2 / r ( i )) * ( 1.0d0 - epsr * ( rmax / ( r ( i ) ** 2 )) * dcos ( 2.0d0 * t ( j ) + Vt_pert_ang )) Vr ( i , j ) = 0.5d0 * zmax * ( rmax ** 2 / r ( i )) * ( epsr * ( rmax / ( r ( i ) ** 2 )) * dsin ( 2.0d0 * t ( j ) + Vt_pert_ang )) end if end do end do end subroutine prod_vortex_structure_L06 !subroutine prod_radar_along_vel() !  implicit none ! !end subroutine prod_radar_along_vel subroutine conv_VtVr2VxVy ( r , t , Vt , Vr , Vx , Vy , undef ) !! Convert Vt and Vr to Vx and Vy on R-T coordinates implicit none double precision , intent ( in ) :: r (:) !! R-coordinate [m] double precision , intent ( in ) :: t (:) !! T-coordinate [rad] double precision , intent ( in ) :: Vt ( size ( r ), size ( t )) !! tangential wind component on R-T coordinates double precision , intent ( in ) :: Vr ( size ( r ), size ( t )) !! radial wind component on R-T coordinates double precision , intent ( out ) :: Vx ( size ( r ), size ( t )) !! X-component of wind on R-T coordinates double precision , intent ( out ) :: Vy ( size ( r ), size ( t )) !! Y-component of wind on R-T coordinates double precision , intent ( in ), optional :: undef !! Undefined value integer :: nr , nt , i , j nr = size ( r ) nt = size ( t ) if ( present ( undef )) then Vx = undef Vy = undef do j = 1 , nt do i = 1 , nr if ( Vt ( i , j ) /= undef . and . Vr ( i , j ) /= undef ) then Vx ( i , j ) = Vr ( i , j ) * dcos ( t ( j )) - Vt ( i , j ) * dsin ( t ( j )) Vy ( i , j ) = Vr ( i , j ) * dsin ( t ( j )) + Vt ( i , j ) * dcos ( t ( j )) end if end do end do else do j = 1 , nt do i = 1 , nr Vx ( i , j ) = Vr ( i , j ) * dcos ( t ( j )) - Vt ( i , j ) * dsin ( t ( j )) Vy ( i , j ) = Vr ( i , j ) * dsin ( t ( j )) + Vt ( i , j ) * dcos ( t ( j )) end do end do end if end subroutine conv_VtVr2VxVy subroutine conv_VxVy2VtVr ( r , t , Vx , Vy , Vt , Vr , undef ) !! Convert Vx and Vy to Vr and Vt on R-T coordinates implicit none double precision , intent ( in ) :: r (:) !! R-coordinate [m] double precision , intent ( in ) :: t (:) !! T-coordinate [rad] double precision , intent ( in ) :: Vx ( size ( r ), size ( t )) !! X-component of wind on R-T coordinates double precision , intent ( in ) :: Vy ( size ( r ), size ( t )) !! Y-component of wind on R-T coordinates double precision , intent ( out ) :: Vt ( size ( r ), size ( t )) !! tangential wind component on R-T coordinates double precision , intent ( out ) :: Vr ( size ( r ), size ( t )) !! radial wind component on R-T coordinates double precision , intent ( in ), optional :: undef !! Undefined value integer :: nr , nt , i , j nr = size ( r ) nt = size ( t ) if ( present ( undef )) then Vr = undef Vt = undef do j = 1 , nt do i = 1 , nr if ( Vx ( i , j ) /= undef . and . Vy ( i , j ) /= undef ) then Vr ( i , j ) = Vx ( i , j ) * dcos ( t ( j )) + Vy ( i , j ) * dsin ( t ( j )) Vt ( i , j ) =- Vx ( i , j ) * dsin ( t ( j )) + Vy ( i , j ) * dcos ( t ( j )) end if end do end do else do j = 1 , nt do i = 1 , nr Vr ( i , j ) = Vx ( i , j ) * dcos ( t ( j )) + Vy ( i , j ) * dsin ( t ( j )) Vt ( i , j ) =- Vx ( i , j ) * dsin ( t ( j )) + Vy ( i , j ) * dcos ( t ( j )) end do end do end if end subroutine conv_VxVy2VtVr subroutine proj_VxVy2Vraxy ( x , y , rax , ray , Vx , Vy , Vraxy , undef ) !! Calculate Vx and Vy to Vd along with radar beams on X-Y coodinates implicit none double precision , intent ( in ) :: x (:) !! X-coordinate double precision , intent ( in ) :: y (:) !! Y-coordinate double precision , intent ( in ) :: rax !! X-coodinate of radar location double precision , intent ( in ) :: ray !! Y-coodinate of radar location double precision , intent ( in ) :: Vx ( size ( x ), size ( y )) !! X-component of wind on X-Y coordinates double precision , intent ( in ) :: Vy ( size ( x ), size ( y )) !! Y-component of wind on X-Y coordinates double precision , intent ( out ) :: Vraxy ( size ( x ), size ( y )) !! velocity along with beam on X-Y coordinates double precision , intent ( in ), optional :: undef !! Undefined value integer :: nx , ny , i , j double precision :: rad nx = size ( x ) ny = size ( y ) if ( present ( undef )) then Vraxy = undef do j = 1 , ny do i = 1 , nx rad = dsqrt (( x ( i ) - rax ) ** 2 + ( y ( j ) - ray ) ** 2 ) if ( rad > 0.0d0 ) then if ( Vx ( i , j ) /= undef . and . Vy ( i , j ) /= undef ) then Vraxy ( i , j ) = (( x ( i ) - rax ) / rad ) * Vx ( i , j ) + (( y ( j ) - ray ) / rad ) * Vy ( i , j ) end if end if end do end do else Vraxy = 0.0d0 do j = 1 , ny do i = 1 , nx rad = dsqrt (( x ( i ) - rax ) ** 2 + ( y ( j ) - ray ) ** 2 ) if ( rad > 0.0d0 ) then Vraxy ( i , j ) = (( x ( i ) - rax ) / rad ) * Vx ( i , j ) + (( y ( j ) - ray ) / rad ) * Vy ( i , j ) end if end do end do end if end subroutine proj_VxVy2Vraxy subroutine proj_VtVr2Vrart ( r , t , td , Vt , Vr , Vra , undef ) !! Convert Vt and Vr to Vx and Vy on R-T coordinates implicit none double precision , intent ( in ) :: r (:) !! R-coordinate [m] double precision , intent ( in ) :: t (:) !! T-coordinate [rad] double precision , intent ( in ) :: td ( size ( r ), size ( t )) !! radar azimuthal angle on R-T coordinate [rad] double precision , intent ( in ) :: Vt ( size ( r ), size ( t )) !! tangential wind component on R-T coordinates double precision , intent ( in ) :: Vr ( size ( r ), size ( t )) !! radial wind component on R-T coordinates double precision , intent ( out ) :: Vra ( size ( r ), size ( t )) !! Velocity along beam on R-T coordinates double precision , intent ( in ), optional :: undef !! undefined value integer :: nr , nt , i , j nr = size ( r ) nt = size ( t ) do j = 1 , nt do i = 1 , nr if ( Vt ( i , j ) /= undef . and . Vr ( i , j ) /= undef . and . td ( i , j ) /= undef ) then Vra ( i , j ) =- Vt ( i , j ) * dsin ( t ( j ) - td ( i , j )) + Vr ( i , j ) * dcos ( t ( j ) - td ( i , j )) else Vra ( i , j ) = undef end if end do end do end subroutine proj_VtVr2Vrart double precision function line_integral ( nr , rdh , gkrr , div_r , undef ) !! Calculate a line integral (actually, sum for arguments) implicit none integer , intent ( in ) :: nr !! Radial grid number double precision , intent ( in ) :: rdh ( nr + 1 ) !! R-coordinate [m] double precision , intent ( in ) :: gkrr ( nr + 1 ) !! Green function double precision , intent ( in ) :: div_r ( nr + 1 ) !! Integral of gkrr double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj double precision :: tmpval double precision :: vareps ( nr + 1 ) tmpval = 0.0d0 vareps = 1.0d0 vareps ( 1 ) = 0.5d0 vareps ( nr + 1 ) = 0.5d0 do ii = 1 , nr + 1 tmpval = tmpval + vareps ( ii ) * rdh ( ii ) * gkrr ( ii ) * div_r ( ii ) end do line_integral = tmpval return end function line_integral double precision function green_func ( rc , r , nval ) !! Calculation of the Green function: ,\\;  <br> !!  G_n(r_c;r)=-(2&#94;{-n})(r/r_c)&#94;n, r<r_c  <br> !!  G_n(r_c;r)=-(2&#94;{-n})(r_c/r)&#94;n, r\\geq r_c  <br> !!  n= nval implicit none double precision , intent ( in ) :: rc !! Source radius double precision , intent ( in ) :: r !! Non-source radius integer , intent ( in ) :: nval !! Order number double precision :: res , nr nr = dble ( nval ) if ( rc < 0.0d0 . or . r < 0.0d0 ) then call stdout ( \"rc and r must not be negative\" , \"green_func\" , 1 ) write ( * , * ) \"rc and r = \" , rc , r end if if ( r == rc ) then res =- ( 0.5d0 / nr ) else if ( r < rc ) then res =- ( 0.5d0 / nr ) * (( r / rc ) ** nval ) else ! (r/rc)**nval == exp(nval*(log(r/rc))) if ( rc == 0.0d0 ) then res = 0.0d0 else res =- ( 0.5d0 / nr ) * exp ( dble ( nval ) * ( log ( rc ) - log ( r ))) end if end if end if green_func = res return end function green_func subroutine div_curl_2d ( r , t , ur , vt , divr , curl , undef ) !! Calculation of rotation and divergence from radial and tangential winds <br> !! divr = \\dfrac{\\partial ru_r}{r\\partial r} + \\dfrac{\\partial v_t}{r\\partial \\theta}  <br> !! curl = \\dfrac{\\partial rv_t}{r\\partial r} - \\dfrac{\\partial u_r}{r\\partial \\theta}  implicit none double precision , intent ( in ) :: r (:) !! radius [m] double precision , intent ( in ) :: t (:) !! angle [rad] double precision , intent ( in ) :: ur ( size ( r ), size ( t )) !! Ur [m/s] double precision , intent ( in ) :: vt ( size ( r ), size ( t )) !! Vt [m/s] double precision , intent ( out ) :: divr ( size ( r ), size ( t )) !! divergence [1/s] double precision , intent ( out ) :: curl ( size ( r ), size ( t )) !! rotation [1/s] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , ni , nj double precision :: dr , dt logical :: undeflag ( size ( r ), size ( t )) ni = size ( r ) nj = size ( t ) dr = r ( 2 ) - r ( 1 ) dt = t ( 2 ) - t ( 1 ) if ( present ( undef )) then divr = undef curl = undef undeflag = . false . do jj = 2 , nj - 1 do ii = 2 , ni - 1 if ( ur ( ii , jj ) == undef . or . vt ( ii , jj ) == undef ) then undeflag ( ii , jj ) = . true . undeflag ( ii - 1 , jj ) = . true . undeflag ( ii + 1 , jj ) = . true . undeflag ( ii , jj - 1 ) = . true . undeflag ( ii , jj + 1 ) = . true . end if end do end do do jj = 2 , nj - 1 if ( ur ( 1 , jj ) == undef . or . vt ( 1 , jj ) == undef ) then undeflag ( 1 , jj ) = . true . undeflag ( 2 , jj ) = . true . undeflag ( 1 , jj - 1 ) = . true . undeflag ( 1 , jj + 1 ) = . true . end if if ( ur ( ni , jj ) == undef . or . vt ( ni , jj ) == undef ) then undeflag ( ni , jj ) = . true . undeflag ( ni - 1 , jj ) = . true . undeflag ( ni , jj - 1 ) = . true . undeflag ( ni , jj + 1 ) = . true . end if end do do ii = 2 , ni - 1 if ( ur ( ii , 1 ) == undef . or . vt ( ii , 1 ) == undef ) then undeflag ( ii , 1 ) = . true . undeflag ( ii - 1 , 1 ) = . true . undeflag ( ii + 1 , 1 ) = . true . undeflag ( ii , 2 ) = . true . end if if ( ur ( ii , nj ) == undef . or . vt ( ii , nj ) == undef ) then undeflag ( ii , nj ) = . true . undeflag ( ii - 1 , nj ) = . true . undeflag ( ii + 1 , nj ) = . true . undeflag ( ii , nj - 1 ) = . true . end if end do if ( ur ( 1 , 1 ) == undef . or . vt ( 1 , 1 ) == undef ) then undeflag ( 1 , 1 ) = . true . undeflag ( 2 , 1 ) = . true . undeflag ( 1 , 2 ) = . true . end if if ( ur ( ni , 1 ) == undef . or . vt ( ni , 1 ) == undef ) then undeflag ( ni , 1 ) = . true . undeflag ( ni - 1 , 1 ) = . true . undeflag ( ni , 2 ) = . true . end if if ( ur ( 1 , nj ) == undef . or . vt ( 1 , nj ) == undef ) then undeflag ( 1 , nj ) = . true . undeflag ( 2 , nj ) = . true . undeflag ( 1 , nj - 1 ) = . true . end if if ( ur ( ni , nj ) == undef . or . vt ( ni , nj ) == undef ) then undeflag ( ni , nj ) = . true . undeflag ( ni - 1 , nj ) = . true . undeflag ( ni , nj - 1 ) = . true . end if do jj = 2 , nj - 1 do ii = 2 , ni - 1 if ( undeflag ( ii , jj ). eqv .. false .) then divr ( ii , jj ) = 0.5d0 * ( ur ( ii + 1 , jj ) - ur ( ii - 1 , jj )) / dr & & + ur ( ii , jj ) / r ( ii ) & & + 0.5d0 * ( vt ( ii , jj + 1 ) - vt ( ii , jj - 1 )) / ( r ( ii ) * dt ) curl ( ii , jj ) = 0.5d0 * ( vt ( ii + 1 , jj ) - vt ( ii - 1 , jj )) / dr & & + vt ( ii , jj ) / r ( ii ) & & - 0.5d0 * ( ur ( ii , jj + 1 ) - ur ( ii , jj - 1 )) / ( r ( ii ) * dt ) end if end do end do if ( r ( 1 ) > 0.0d0 ) then do jj = 2 , nj - 1 if ( undeflag ( 1 , jj ). eqv .. false .) then divr ( 1 , jj ) = ( ur ( 2 , jj ) - ur ( 1 , jj )) / dr & & + ur ( 1 , jj ) / r ( 1 ) & & + 0.5d0 * ( vt ( 1 , jj + 1 ) - vt ( 1 , jj - 1 )) / ( r ( 1 ) * dt ) curl ( 1 , jj ) = ( vt ( 2 , jj ) - vt ( 1 , jj )) / dr & & + vt ( 1 , jj ) / r ( 1 ) & & - 0.d50 * ( ur ( 1 , jj + 1 ) - ur ( 1 , jj - 1 )) / ( r ( 1 ) * dt ) end if end do end if do jj = 2 , nj - 1 if ( undeflag ( ni , jj ). eqv .. false .) then divr ( ni , jj ) = ( ur ( ni , jj ) - ur ( ni - 1 , jj )) / dr & & + ur ( ni , jj ) / r ( ni ) & & + 0.5d0 * ( vt ( ni , jj + 1 ) - vt ( ni , jj - 1 )) / ( r ( ni ) * dt ) curl ( ni , jj ) = ( vt ( ni , jj ) - vt ( ni - 1 , jj )) / dr & & + vt ( ni , jj ) / r ( ni ) & & - 0.5d0 * ( ur ( ni , jj + 1 ) - ur ( ni , jj - 1 )) / ( r ( ni ) * dt ) end if end do do ii = 2 , ni - 1 if ( undeflag ( ii , 1 ). eqv .. false .) then divr ( ii , 1 ) = 0.5d0 * ( ur ( ii + 1 , 1 ) - ur ( ii - 1 , 1 )) / dr & & + ur ( ii , 1 ) / r ( ii ) & & + ( vt ( ii , 2 ) - vt ( ii , 1 )) / ( r ( ii ) * dt ) curl ( ii , 1 ) = 0.5d0 * ( vt ( ii + 1 , 1 ) - vt ( ii - 1 , 1 )) / dr & & + vt ( ii , 1 ) / r ( ii ) & & - ( ur ( ii , 2 ) - ur ( ii , 1 )) / ( r ( ii ) * dt ) end if if ( undeflag ( ii , nj ). eqv .. false .) then divr ( ii , nj ) = 0.5d0 * ( ur ( ii + 1 , nj ) - ur ( ii - 1 , nj )) / dr & & + ur ( ii , nj ) / r ( ii ) & & + ( vt ( ii , nj ) - vt ( ii , nj - 1 )) / ( r ( ii ) * dt ) curl ( ii , nj ) = 0.5d0 * ( vt ( ii + 1 , nj ) - vt ( ii - 1 , nj )) / dr & & + vt ( ii , nj ) / r ( ii ) & & - ( ur ( ii , nj ) - ur ( ii , nj - 1 )) / ( r ( ii ) * dt ) end if end do if ( r ( 1 ) > 0.0d0 ) then if ( undeflag ( 1 , 1 ). eqv .. false .) then divr ( 1 , 1 ) = ( ur ( 2 , 1 ) - ur ( 1 , 1 )) / dr & & + ur ( 1 , 1 ) / r ( 1 ) & & + ( vt ( 1 , 2 ) - vt ( 1 , 1 )) / ( r ( 1 ) * dt ) curl ( 1 , 1 ) = ( vt ( 2 , 1 ) - vt ( 1 , 1 )) / dr & & + vt ( 1 , 1 ) / r ( 1 ) & & - ( ur ( 1 , 2 ) - ur ( 1 , 1 )) / ( r ( 1 ) * dt ) end if if ( undeflag ( 1 , nj ). eqv .. false .) then divr ( 1 , nj ) = ( ur ( 2 , nj ) - ur ( 1 , nj )) / dr & & + ur ( 1 , nj ) / r ( 1 ) & & + ( vt ( 1 , nj ) - vt ( 1 , nj - 1 )) / ( r ( 1 ) * dt ) curl ( 1 , nj ) = ( vt ( 2 , nj ) - vt ( 1 , nj )) / dr & & + vt ( 1 , nj ) / r ( 1 ) & & - ( ur ( 1 , nj ) - ur ( 1 , nj - 1 )) / ( r ( 1 ) * dt ) end if end if if ( undeflag ( ni , 1 ). eqv .. false .) then divr ( ni , 1 ) = ( ur ( ni , 1 ) - ur ( ni - 1 , 1 )) / dr & & + ur ( ni , 1 ) / r ( ni ) & & + ( vt ( ni , 2 ) - vt ( ni , 1 )) / ( r ( ni ) * dt ) curl ( ni , 1 ) = ( vt ( ni , 1 ) - vt ( ni - 1 , 1 )) / dr & & + vt ( ni , 1 ) / r ( ni ) & & - ( ur ( ni , 2 ) - ur ( ni , 1 )) / ( r ( ni ) * dt ) end if if ( undeflag ( ni , nj ). eqv .. false .) then divr ( ni , nj ) = ( ur ( ni , nj ) - ur ( ni - 1 , nj )) / dr & & + ur ( ni , nj ) / r ( ni ) & & + ( vt ( ni , nj ) - vt ( ni , nj - 1 )) / ( r ( ni ) * dt ) curl ( ni , nj ) = ( vt ( ni , nj ) - vt ( ni - 1 , nj )) / dr & & + vt ( ni , nj ) / r ( ni ) & & - ( ur ( ni , nj ) - ur ( ni , nj - 1 )) / ( r ( ni ) * dt ) end if else divr = 0.0d0 curl = 0.0d0 do jj = 2 , nj - 1 do ii = 2 , ni - 1 divr ( ii , jj ) = 0.5d0 * ( ur ( ii + 1 , jj ) - ur ( ii - 1 , jj )) / dr & & + ur ( ii , jj ) / r ( ii ) & & + 0.5d0 * ( vt ( ii , jj + 1 ) - vt ( ii , jj - 1 )) / ( r ( ii ) * dt ) curl ( ii , jj ) = 0.5d0 * ( vt ( ii + 1 , jj ) - vt ( ii - 1 , jj )) / dr & & + vt ( ii , jj ) / r ( ii ) & & - 0.5d0 * ( ur ( ii , jj + 1 ) - ur ( ii , jj - 1 )) / ( r ( ii ) * dt ) end do end do if ( r ( 1 ) > 0.0d0 ) then do jj = 2 , nj - 1 divr ( 1 , jj ) = ( ur ( 2 , jj ) - ur ( 1 , jj )) / dr & & + ur ( 1 , jj ) / r ( 1 ) & & + 0.5d0 * ( vt ( 1 , jj + 1 ) - vt ( 1 , jj - 1 )) / ( r ( 1 ) * dt ) curl ( 1 , jj ) = ( vt ( 2 , jj ) - vt ( 1 , jj )) / dr & & + vt ( 1 , jj ) / r ( 1 ) & & - 0.d50 * ( ur ( 1 , jj + 1 ) - ur ( 1 , jj - 1 )) / ( r ( 1 ) * dt ) divr ( ni , jj ) = ( ur ( ni , jj ) - ur ( ni - 1 , jj )) / dr & & + ur ( ni , jj ) / r ( ni ) & & + 0.5d0 * ( vt ( ni , jj + 1 ) - vt ( ni , jj - 1 )) / ( r ( ni ) * dt ) curl ( ni , jj ) = ( vt ( ni , jj ) - vt ( ni - 1 , jj )) / dr & & + vt ( ni , jj ) / r ( ni ) & & - 0.5d0 * ( ur ( ni , jj + 1 ) - ur ( ni , jj - 1 )) / ( r ( ni ) * dt ) end do else do jj = 2 , nj - 1 divr ( ni , jj ) = ( ur ( ni , jj ) - ur ( ni - 1 , jj )) / dr & & + ur ( ni , jj ) / r ( ni ) & & + 0.5d0 * ( vt ( ni , jj + 1 ) - vt ( ni , jj - 1 )) / ( r ( ni ) * dt ) curl ( ni , jj ) = ( vt ( ni , jj ) - vt ( ni - 1 , jj )) / dr & & + vt ( ni , jj ) / r ( ni ) & & - 0.5d0 * ( ur ( ni , jj + 1 ) - ur ( ni , jj - 1 )) / ( r ( ni ) * dt ) end do end if do ii = 2 , ni - 1 divr ( ii , 1 ) = 0.5d0 * ( ur ( ii + 1 , 1 ) - ur ( ii - 1 , 1 )) / dr & & + ur ( ii , 1 ) / r ( ii ) & & + ( vt ( ii , 2 ) - vt ( ii , 1 )) / ( r ( ii ) * dt ) curl ( ii , 1 ) = 0.5d0 * ( vt ( ii + 1 , 1 ) - vt ( ii - 1 , 1 )) / dr & & + vt ( ii , 1 ) / r ( ii ) & & - ( ur ( ii , 2 ) - ur ( ii , 1 )) / ( r ( ii ) * dt ) divr ( ii , nj ) = 0.5d0 * ( ur ( ii + 1 , nj ) - ur ( ii - 1 , nj )) / dr & & + ur ( ii , nj ) / r ( ii ) & & + ( vt ( ii , nj ) - vt ( ii , nj - 1 )) / ( r ( ii ) * dt ) curl ( ii , nj ) = 0.5d0 * ( vt ( ii + 1 , nj ) - vt ( ii - 1 , nj )) / dr & & + vt ( ii , nj ) / r ( ii ) & & - ( ur ( ii , nj ) - ur ( ii , nj - 1 )) / ( r ( ii ) * dt ) end do if ( r ( 1 ) > 0.0d0 ) then divr ( 1 , 1 ) = ( ur ( 2 , 1 ) - ur ( 1 , 1 )) / dr & & + ur ( 1 , 1 ) / r ( 1 ) & & + ( vt ( 1 , 2 ) - vt ( 1 , 1 )) / ( r ( 1 ) * dt ) curl ( 1 , 1 ) = ( vt ( 2 , 1 ) - vt ( 1 , 1 )) / dr & & + vt ( 1 , 1 ) / r ( 1 ) & & - ( ur ( 1 , 2 ) - ur ( 1 , 1 )) / ( r ( 1 ) * dt ) divr ( 1 , nj ) = ( ur ( 2 , nj ) - ur ( 1 , nj )) / dr & & + ur ( 1 , nj ) / r ( 1 ) & & + ( vt ( 1 , nj ) - vt ( 1 , nj - 1 )) / ( r ( 1 ) * dt ) curl ( 1 , nj ) = ( vt ( 2 , nj ) - vt ( 1 , nj )) / dr & & + vt ( 1 , nj ) / r ( 1 ) & & - ( ur ( 1 , nj ) - ur ( 1 , nj - 1 )) / ( r ( 1 ) * dt ) end if divr ( ni , 1 ) = ( ur ( ni , 1 ) - ur ( ni - 1 , 1 )) / dr & & + ur ( ni , 1 ) / r ( ni ) & & + ( vt ( ni , 2 ) - vt ( ni , 1 )) / ( r ( ni ) * dt ) curl ( ni , 1 ) = ( vt ( ni , 1 ) - vt ( ni - 1 , 1 )) / dr & & + vt ( ni , 1 ) / r ( ni ) & & - ( ur ( ni , 2 ) - ur ( ni , 1 )) / ( r ( ni ) * dt ) divr ( ni , nj ) = ( ur ( ni , nj ) - ur ( ni - 1 , nj )) / dr & & + ur ( ni , nj ) / r ( ni ) & & + ( vt ( ni , nj ) - vt ( ni , nj - 1 )) / ( r ( ni ) * dt ) curl ( ni , nj ) = ( vt ( ni , nj ) - vt ( ni - 1 , nj )) / dr & & + vt ( ni , nj ) / r ( ni ) & & - ( ur ( ni , nj ) - ur ( ni , nj - 1 )) / ( r ( ni ) * dt ) end if end subroutine div_curl_2d subroutine conv_d2r_1d ( ival , oval ) !! Convert double to real implicit none double precision , intent ( in ) :: ival (:) !! Input real , intent ( out ) :: oval ( size ( ival )) !! Output integer :: ii , ni ni = size ( ival ) do ii = 1 , ni oval ( ii ) = real ( ival ( ii )) end do end subroutine conv_d2r_1d subroutine conv_d2r_2d ( ival , oval ) !! Convert double to real implicit none double precision , intent ( in ) :: ival (:,:) !! Input real , intent ( out ) :: oval ( size ( ival , 1 ), size ( ival , 2 )) !! Output integer :: ii , jj , ni , nj ni = size ( ival , 1 ) nj = size ( ival , 2 ) do jj = 1 , nj do ii = 1 , ni oval ( ii , jj ) = real ( ival ( ii , jj )) end do end do end subroutine conv_d2r_2d subroutine sum_1d ( val , res , undef ) !! Calculation of sum for 1D variable implicit none double precision , intent ( in ) :: val (:) !! input double precision , intent ( out ) :: res !! output double precision , intent ( in ), optional :: undef integer :: ii , ni , icount ni = size ( val ) icount = 0 res = 0.0d0 if ( present ( undef )) then do ii = 1 , ni if ( val ( ii ) /= undef ) then res = res + val ( ii ) icount = icount + 1 end if end do if ( icount > 0 ) then res = res / dble ( icount ) else res = undef end if else do ii = 1 , ni res = res + val ( ii ) end do res = res / dble ( ni ) end if end subroutine sum_1d subroutine add_2d ( ioval , ival , undef ) !! add ival implicit none double precision , intent ( inout ) :: ioval (:,:) !! Base value double precision , intent ( in ) :: ival ( size ( ioval , 1 ), size ( ioval , 2 )) !! added double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , ni , nj ni = size ( ioval , 1 ) nj = size ( ioval , 2 ) if ( present ( undef )) then do jj = 1 , nj do ii = 1 , ni if ( ioval ( ii , jj ) /= undef . and . ival ( ii , jj ) /= undef ) then ioval ( ii , jj ) = ioval ( ii , jj ) + ival ( ii , jj ) else ioval ( ii , jj ) = undef end if end do end do else do jj = 1 , nj do ii = 1 , ni ioval ( ii , jj ) = ioval ( ii , jj ) + ival ( ii , jj ) end do end do end if end subroutine add_2d subroutine subst_2d ( ioval , ival , undef ) !! subtract ival implicit none double precision , intent ( inout ) :: ioval (:,:) !! Base value double precision , intent ( in ) :: ival ( size ( ioval , 1 ), size ( ioval , 2 )) !! Subtracted double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , ni , nj ni = size ( ioval , 1 ) nj = size ( ioval , 2 ) if ( present ( undef )) then do jj = 1 , nj do ii = 1 , ni if ( ioval ( ii , jj ) /= undef . and . ival ( ii , jj ) /= undef ) then ioval ( ii , jj ) = ioval ( ii , jj ) - ival ( ii , jj ) else ioval ( ii , jj ) = undef end if end do end do else do jj = 1 , nj do ii = 1 , ni ioval ( ii , jj ) = ioval ( ii , jj ) - ival ( ii , jj ) end do end do end if end subroutine subst_2d subroutine subst_2d_r ( ioval , ival , undef ) !! subtract ival implicit none real , intent ( inout ) :: ioval (:,:) !! Base value real , intent ( in ) :: ival ( size ( ioval , 1 ), size ( ioval , 2 )) !! Subtracted value real , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , ni , nj ni = size ( ioval , 1 ) nj = size ( ioval , 2 ) if ( present ( undef )) then do jj = 1 , nj do ii = 1 , ni if ( ioval ( ii , jj ) /= undef . and . ival ( ii , jj ) /= undef ) then ioval ( ii , jj ) = ioval ( ii , jj ) - ival ( ii , jj ) else ioval ( ii , jj ) = undef end if end do end do else do jj = 1 , nj do ii = 1 , ni ioval ( ii , jj ) = ioval ( ii , jj ) - ival ( ii , jj ) end do end do end if end subroutine subst_2d_r subroutine rearrange_3d_2d ( val3d , val2d ) !! Rearrange 3d variable to 2d variable (k,i,j -> i*j,k) implicit none double precision , intent ( in ) :: val3d (:,:,:) !! Input double precision , intent ( out ) :: val2d ( size ( val3d , 2 ) * size ( val3d , 3 ), size ( val3d , 1 )) !! Output integer :: ii , jj , kk , ni , nj , nk nk = size ( val3d , 1 ) ni = size ( val3d , 2 ) nj = size ( val3d , 3 ) do kk = 1 , nk do jj = 1 , nj do ii = 1 , ni val2d ( ni * ( jj - 1 ) + ii , kk ) = val3d ( kk , ii , jj ) end do end do end do end subroutine rearrange_3d_2d subroutine rearrange_2d_1d ( val2d , val1d ) !! Rearrange 2d variable to 1d variable (i,j -> i*j) implicit none double precision , intent ( in ) :: val2d (:,:) !! Input double precision , intent ( out ) :: val1d ( size ( val2d , 1 ) * size ( val2d , 2 )) !! Output integer :: ii , jj , ni , nj ni = size ( val2d , 1 ) nj = size ( val2d , 2 ) do jj = 1 , nj do ii = 1 , ni val1d ( ni * ( jj - 1 ) + ii ) = val2d ( ii , jj ) end do end do end subroutine rearrange_2d_1d subroutine display_2valdiff_max ( val1 , val2 , undef , cout ) !! Display the maximum of the difference between val1 and val2 implicit none double precision , intent ( in ) :: val1 (:,:) !! Input 1 double precision , intent ( in ) :: val2 ( size ( val1 , 1 ), size ( val1 , 2 )) !! Input 2 double precision , intent ( in ), optional :: undef !! Undefined value character ( * ), intent ( out ), optional :: cout !! Maximum value by character integer :: ii , jj , ni , nj , maxi , maxj double precision :: maxv , dval ni = size ( val1 , 1 ) nj = size ( val1 , 2 ) maxv = 0.0d0 maxi = 0 maxj = 0 if ( present ( undef )) then do jj = 1 , nj do ii = 1 , ni if ( val1 ( ii , jj ) /= undef . and . val2 ( ii , jj ) /= undef ) then dval = dabs ( val1 ( ii , jj ) - val2 ( ii , jj )) if ( maxv < dval ) then maxv = dval maxi = ii maxj = jj end if end if end do end do else do jj = 1 , nj do ii = 1 , ni dval = dabs ( val1 ( ii , jj ) - val2 ( ii , jj )) if ( maxv < dval ) then maxv = dval maxi = ii maxj = jj end if end do end do end if write ( * , '(a21,1PE16.8,a5,i4,a1,i4,a2)' ) \"Maximum difference = \" , maxv , & & \" at (\" , maxi , \",\" , maxj , \").\" if ( present ( cout )) then write ( cout , '(1PE8.1)' ) maxv end if end subroutine display_2valdiff_max subroutine stdout ( message , routine_name , mtype ) !! Standard output for message implicit none character ( * ), intent ( in ) :: message !! output message character ( * ), intent ( in ) :: routine_name !! called routine name integer , intent ( in ) :: mtype !! message type !! 0: message, -1: error, 1: warning character ( 100 ) :: tname , forma character ( 10000 ) :: all_mess tname = '' all_mess = '' select case ( mtype ) case ( 0 ) ! message tname ( 1 : 7 ) = \"MESSAGE\" case ( - 1 ) ! error tname ( 1 : 5 ) = \"ERROR\" case ( 1 ) ! warning tname ( 1 : 7 ) = \"WARNING\" end select all_mess = \"*** \" // trim ( adjustl ( tname )) // \"(\" // trim ( adjustl ( routine_name )) & & // \") *** : \" // trim ( adjustl ( message )) write ( forma , * ) len_trim ( adjustl ( all_mess )) forma = '(a' // trim ( adjustl ( forma )) // ')' write ( 6 , trim ( adjustl ( forma ))) trim ( adjustl ( all_mess )) end subroutine stdout !------------------------------------------------------------! ! Reuse the subroutine from the STPK library (0.9.20.0)      ! ! STPK library (LGPL2.1):                                    ! ! https://www.gfd-dennou.org/library/davis/stpk/index.htm.en ! !------------------------------------------------------------! subroutine fp_gauss ( c , d , x ) !! Gauss-Jordan method with fully pivotting (from STPK) implicit none double precision , intent ( in ) :: d (:) !! Vector double precision , intent ( in ) :: c ( size ( d ), size ( d )) !! Square matrix (array is the first elements) double precision , intent ( inout ) :: x ( size ( d )) !! Vector for unknown variables !-- internal variables double precision :: b ( size ( d )) ! == d double precision :: a ( size ( d ), size ( d )) ! == c double precision :: s , pivotb ! working variables for pivotting double precision :: pivot ( size ( d ) + 1 ), y ( size ( d )) ! working variables for pivotting integer :: i , j , k , nmax , pivi , pivj , ipv integer :: ipivot ( size ( d )) ! temporary store of the original values for replacement nmax = size ( b ) do k = 1 , nmax do j = 1 , nmax a ( k , j ) = c ( j , k ) ! Replacement between the column and array end do b ( k ) = d ( k ) ipivot ( k ) = k end do !-- Forward erasure --- !-- Forward erasure for a(i,j) --- do k = 1 , nmax - 1 !-- Start the pivotting procedure --- !-- Determine the maximum value in the matrix elements --- pivi = k pivj = k do i = k , nmax do j = k , nmax if ( dabs ( a ( i , j )). gt . dabs ( a ( pivi , pivj ))) then pivi = i pivj = j end if end do end do ipv = ipivot ( pivj ) ipivot ( pivj ) = ipivot ( k ) ipivot ( k ) = ipv !-- Replacing the column with the maximum value to the current column --- do i = 1 , nmax pivot ( i ) = a ( i , k ) a ( i , k ) = a ( i , pivj ) a ( i , pivj ) = pivot ( i ) end do !-- Replacing the array with the maximum value to the current array --- do j = k , nmax pivot ( j ) = a ( k , j ) a ( k , j ) = a ( pivi , j ) a ( pivi , j ) = pivot ( j ) end do pivotb = b ( k ) b ( k ) = b ( pivi ) b ( pivi ) = pivotb if ( dabs ( a ( k , k )) <= 1.0d-10 ) then write ( * , * ) \"detect small\" , a ( k , k : nmax ) end if !-- End the pivotting procedure --- do i = k + 1 , nmax a ( k , i ) = a ( k , i ) / a ( k , k ) end do b ( k ) = b ( k ) / a ( k , k ) a ( k , k ) = 1.0d0 do j = k + 1 , nmax do i = k + 1 , nmax a ( j , i ) = a ( j , i ) - a ( k , i ) * a ( j , k ) end do b ( j ) = b ( j ) - b ( k ) * a ( j , k ) a ( j , k ) = 0.0d0 end do end do b ( nmax ) = b ( nmax ) / a ( nmax , nmax ) a ( nmax , nmax ) = 1.0d0 !-- Back substitution of x(i) y ( nmax ) = b ( nmax ) do i = nmax - 1 , 1 , - 1 s = b ( i ) do j = i + 1 , nmax s = s - a ( i , j ) * y ( j ) end do y ( i ) = s end do do i = 1 , nmax x ( ipivot ( i )) = y ( i ) end do end subroutine fp_gauss !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine fp_invert_mat ( ax , xx ) !! Calculate the inverse \"xx\" for the matrix \"ax\" (from STPK) implicit none double precision , intent ( in ) :: ax (:,:) !! Input matrix double precision , intent ( inout ) :: xx ( size ( ax , 1 ), size ( ax , 2 )) !! Inverse integer :: i , j , k double precision :: c ( size ( ax , 1 ), size ( ax , 2 )) double precision :: d ( size ( ax , 1 ), size ( ax , 2 )) integer :: nx nx = size ( ax , 1 ) c = 0.0d0 do i = 1 , nx c ( i , i ) = 1.0d0 end do d ( 1 : nx , 1 : nx ) = ax ( 1 : nx , 1 : nx ) !$omp parallel default(shared) !$omp do schedule(runtime) private(i) do i = 1 , nx call fp_gauss ( d , c ( 1 : nx , i ), xx ( 1 : nx , i ) ) end do !$omp end do !$omp end parallel end subroutine fp_invert_mat !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine tangent_conv_scal ( x , y , xc , yc , u , r , theta , v , & & undef , undefg , stdopt ) !! Convert the Cartesian grid to polar grid with the origin of !!  the storm center (from STPK) !! The procedure: !! (1) Define the given polar grid (r-theta) on the Cartesian grid !! (2) Search the 4 nearest points on the Cartesian grid (x-y) for each polar grid point !! (3) Performing the bilinear interpolation of the 4 values defined on the !!     Cartesian grid to the polar grid. implicit none double precision , intent ( in ) :: x (:) !! X-coordinate on the Cartesian grid double precision , intent ( in ) :: y (:) !! Y-coordinate on the Cartesian grid double precision , intent ( in ) :: u ( size ( x ), size ( y )) !! Values defined on the Cartesian grid double precision , intent ( in ) :: xc !! X-component of the storm center double precision , intent ( in ) :: yc !! Y-component of the storm center double precision , intent ( in ) :: r (:) !! R-coordinate on the polar grid with the origin (xc, yc). double precision , intent ( in ) :: theta (:) !! theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision , intent ( out ) :: v ( size ( r ), size ( theta )) !! Values converted to the polar grid double precision , intent ( in ), optional :: undef !! Missing value for the outside of the polar grid area (default: -999.0) double precision , intent ( in ), optional :: undefg !! Missing value for the inside of the polar grid area (default: -999.0) logical , intent ( in ), optional :: stdopt !! Display debug messages. !! (default: .false. == No display) !-- internal variables integer :: i , j , nx , ny , nr , nt , i_undef double precision :: r_undef , r_undefg double precision :: work ( size ( r ), size ( theta )) double precision :: point ( size ( r ), size ( theta ), 2 ) integer :: ip ( size ( r ), size ( theta ), 2 ) double precision :: tmpx ( 2 ), tmpy ( 2 ), tmpz ( 2 , 2 ), inter ( 2 ) double precision :: tmppointd1 , tmppointd2 logical :: ucf , stderr nx = size ( x ) ny = size ( y ) nr = size ( r ) nt = size ( theta ) i_undef = 0 if ( present ( undef )) then r_undef = undef else r_undef =- 99 9.0d0 end if if ( present ( undefg )) then r_undefg = undefg else r_undefg =- 99 9.0d0 end if if ( present ( stdopt )) then stderr = stdopt else stderr = . false . end if !-- Process (1) --- do j = 1 , nt do i = 1 , nr call rt_2_xy ( r ( i ), theta ( j ), point ( i , j , 1 ), point ( i , j , 2 ) ) point ( i , j , 1 ) = xc + point ( i , j , 1 ) point ( i , j , 2 ) = yc + point ( i , j , 2 ) end do end do !-- Process (2) --- do j = 1 , nt do i = 1 , nr call interpo_search_2d ( x , y , point ( i , j , 1 ), point ( i , j , 2 ), & & ip ( i , j , 1 ), ip ( i , j , 2 ), undeff = i_undef , & & stdopt = stderr ) end do end do !-- Process (3) --- do j = 1 , nt do i = 1 , nr if ( ip ( i , j , 1 ) /= i_undef . and . ip ( i , j , 2 ) /= i_undef . and . & & ip ( i , j , 1 ) /= nx . and . ip ( i , j , 2 ) /= ny ) then tmpx ( 1 ) = x ( ip ( i , j , 1 )) tmpx ( 2 ) = x ( ip ( i , j , 1 ) + 1 ) tmpy ( 1 ) = y ( ip ( i , j , 2 )) tmpy ( 2 ) = y ( ip ( i , j , 2 ) + 1 ) tmpz ( 1 , 1 ) = u ( ip ( i , j , 1 ), ip ( i , j , 2 )) tmpz ( 2 , 1 ) = u ( ip ( i , j , 1 ) + 1 , ip ( i , j , 2 )) tmpz ( 1 , 2 ) = u ( ip ( i , j , 1 ), ip ( i , j , 2 ) + 1 ) tmpz ( 2 , 2 ) = u ( ip ( i , j , 1 ) + 1 , ip ( i , j , 2 ) + 1 ) inter ( 1 ) = point ( i , j , 1 ) inter ( 2 ) = point ( i , j , 2 ) if ( present ( undefg )) then ucf = undef_checker_2d ( tmpz , undefg ) if ( ucf . eqv .. false .) then call interpolation_2d ( tmpx , tmpy , tmpz , inter , work ( i , j ) ) else work ( i , j ) = r_undefg end if else call interpolation_2d ( tmpx , tmpy , tmpz , inter , work ( i , j ) ) end if else work ( i , j ) = r_undef end if end do end do do j = 1 , nt do i = 1 , nr v ( i , j ) = work ( i , j ) end do end do end subroutine tangent_conv_scal !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine cart_conv_scal ( r , theta , v , x , y , xc , yc , u , & & undef , undefg , stdopt ) !! Convert polar grid with the origin of the storm center to !!  the Cartesian grid (from STPK) !! The procedure: !! (1) Define the given Cartesian grid (x-y) on the polar grid !! (2) Search the 4 nearest points on the polar grid for each Cartesian grid point !! (3) Performing the bilinear interpolation of the 4 values defined on the !!     polar grid to the Cartesian grid. implicit none double precision , intent ( in ) :: r (:) !! R-coordinate on the polar grid with the origin (xc, yc). double precision , intent ( in ) :: theta (:) !! theta-coordinate of the polar grid with the origin (xc, yc) [rad] double precision , intent ( in ) :: v ( size ( r ), size ( theta )) !! Values defined on the polar grid double precision , intent ( in ) :: x (:) !! X-coordinate on the Cartesian grid double precision , intent ( in ) :: y (:) !! Y-coordinate on the Cartesian grid double precision , intent ( in ) :: xc !! X-component of the storm center double precision , intent ( in ) :: yc !! Y-component of the storm center double precision , intent ( out ) :: u ( size ( x ), size ( y )) !! Values converted to the Cartesian grid double precision , intent ( in ), optional :: undef !! Missing value for the outside of the Cartesian grid area (default: -999.0) double precision , intent ( in ), optional :: undefg !! Missing value for the inside of the Cartesian grid area (default: -999.0) logical , intent ( in ), optional :: stdopt !! Display debug messages. !! (default: .false. == No display) !-- internal variables integer :: i , j , nx , ny , nr , nt , i_undef double precision :: r_undef , r_undefg double precision :: work ( size ( x ), size ( y )) double precision :: point ( size ( x ), size ( y ), 2 ) integer :: ip ( size ( x ), size ( y ), 2 ) double precision :: tmpx ( 2 ), tmpy ( 2 ), tmpz ( 2 , 2 ), inter ( 2 ) double precision :: tmppoint1 , tmppoint2 logical :: ucf , stderr nx = size ( x ) ny = size ( y ) nr = size ( r ) nt = size ( theta ) i_undef = 0 if ( present ( undef )) then r_undef = undef else r_undef =- 99 9.0d0 end if if ( present ( undefg )) then r_undefg = undefg else r_undefg =- 99 9.0d0 end if if ( present ( stdopt )) then stderr = stdopt else stderr = . false . end if !-- Process (1) --- do j = 1 , ny do i = 1 , nx call xy_2_rt ( x ( i ), y ( j ), xc , yc , point ( i , j , 1 ), point ( i , j , 2 ) ) !         if(point(i,j,2)<0.0d0)then !            point(i,j,2)=point(i,j,2)+2.0d0*pi_dp !         end if if ( point ( i , j , 2 ) < theta ( 1 )) then ! +2pi do while ( point ( i , j , 2 ) < theta ( 1 )) point ( i , j , 2 ) = point ( i , j , 2 ) + 2.0d0 * pi_dp end do else if ( point ( i , j , 2 ) > theta ( nt )) then ! -2pi do while ( point ( i , j , 2 ) > theta ( nt )) point ( i , j , 2 ) = point ( i , j , 2 ) - 2.0d0 * pi_dp end do end if end do end do !-- Process (2) --- do j = 1 , ny do i = 1 , nx call interpo_search_2d ( r , theta , point ( i , j , 1 ), point ( i , j , 2 ), & & ip ( i , j , 1 ), ip ( i , j , 2 ), undeff = i_undef , & & stdopt = stderr ) end do end do !-- Process (3) --- do j = 1 , ny do i = 1 , nx if ( ip ( i , j , 1 ) /= i_undef . and . ip ( i , j , 2 ) /= i_undef . and . & & ip ( i , j , 1 ) /= nr . and . ip ( i , j , 2 ) /= nt ) then tmpx ( 1 ) = r ( ip ( i , j , 1 )) tmpx ( 2 ) = r ( ip ( i , j , 1 ) + 1 ) tmpy ( 1 ) = theta ( ip ( i , j , 2 )) tmpy ( 2 ) = theta ( ip ( i , j , 2 ) + 1 ) tmpz ( 1 , 1 ) = v ( ip ( i , j , 1 ), ip ( i , j , 2 )) tmpz ( 2 , 1 ) = v ( ip ( i , j , 1 ) + 1 , ip ( i , j , 2 )) tmpz ( 1 , 2 ) = v ( ip ( i , j , 1 ), ip ( i , j , 2 ) + 1 ) tmpz ( 2 , 2 ) = v ( ip ( i , j , 1 ) + 1 , ip ( i , j , 2 ) + 1 ) inter ( 1 ) = point ( i , j , 1 ) inter ( 2 ) = point ( i , j , 2 ) if ( present ( undefg )) then ucf = undef_checker_2d ( tmpz , undefg ) if ( ucf . eqv .. false .) then call interpolation_2d ( tmpx , tmpy , tmpz , inter , work ( i , j ) ) else work ( i , j ) = r_undefg end if else call interpolation_2d ( tmpx , tmpy , tmpz , inter , work ( i , j ) ) end if else work ( i , j ) = r_undef end if end do end do do j = 1 , ny do i = 1 , nx u ( i , j ) = work ( i , j ) end do end do end subroutine cart_conv_scal !-------------------------------------------------------------- !-------------------------------------------------------------- logical function undef_checker_2d ( val , undef ) !! Check missing value in \"val\" implicit none double precision , dimension (:,:), intent ( in ) :: val !! Input double precision , intent ( in ) :: undef !! Undefined value integer :: i , nx logical :: checker nx = size ( val , 2 ) checker = . false . do i = 1 , nx checker = undef_checker_1d ( val (:, i ), undef ) if ( checker . eqv .. true .) then exit end if end do undef_checker_2d = checker return end function undef_checker_2d !-------------------------------------------------------------- !-------------------------------------------------------------- logical function undef_checker_1d ( val , undef ) !! Check missing value in \"val\" implicit none double precision , dimension (:), intent ( in ) :: val !! Input double precision , intent ( in ) :: undef !! Undefined value integer :: i , nx logical :: checker nx = size ( val ) checker = . false . do i = 1 , nx if ( val ( i ) == undef ) then checker = . true . exit end if end do undef_checker_1d = checker return end function undef_checker_1d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine interpo_search_2d ( x , y , pointx , pointy , i , j , undeff , stdopt ) !! Floor function for the real grid points (from STPK) implicit none double precision , intent ( in ) :: x (:) !! X-coordinate double precision , intent ( in ) :: y (:) !! Y-coordinate double precision , intent ( in ) :: pointx !! The X point in real double precision , intent ( in ) :: pointy !! The Y point in real integer , intent ( out ) :: i !! floor(pointx) integer , intent ( out ) :: j !! floor(pointy) integer , intent ( in ), optional :: undeff !! In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j !! (default = 0) logical , intent ( in ), optional :: stdopt !! Display debug messages !! (default = .false. = Not display) !-- internal variables integer :: just logical :: stderr if ( present ( stdopt )) then stderr = stdopt else stderr = . false . end if if ( present ( undeff )) then just = undeff call interpo_search_1d ( x , pointx , i , just , stdopt = stderr ) call interpo_search_1d ( y , pointy , j , just , stdopt = stderr ) else call interpo_search_1d ( x , pointx , i , stdopt = stderr ) call interpo_search_1d ( y , pointy , j , stdopt = stderr ) end if end subroutine interpo_search_2d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine interpo_search_1d ( x , point , i , undeff , stdopt ) !! Floor function for the real grid points (from STPK) implicit none double precision , intent ( in ) :: x (:) !! X-coordinate double precision , intent ( in ) :: point !! The X point in real integer , intent ( out ) :: i !! floor(pointx) integer , intent ( in ), optional :: undeff !! In case of (x(1)>pointx or y(1)>pointy), the value returned to i and j !! (default = 0) logical , intent ( in ), optional :: stdopt !! Display debug messages !! (default = .false. = Not display) !-- internal variables integer :: nx , j integer :: just logical :: stderr nx = size ( x ) if ( present ( undeff )) then just = undeff else just = 0 end if if ( present ( stdopt )) then stderr = stdopt else stderr = . false . end if if ( x ( 1 ) > point ) then if ( stderr . eqv .. false .) then write ( * , * ) \"****** WARNING ******\" write ( * , * ) \"searching point was not found :\" , x ( 1 ), point write ( * , * ) \"Abort. Exit.!!!\" end if i = just else do j = 1 , nx if ( x ( j ) <= point ) then i = j else exit end if end do end if end subroutine interpo_search_1d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine xy_2_rt ( x , y , xc , yc , r , t ) !! Convert the Cartesian (x-y) grid to the polar (r-t) grid (from STPK) implicit none double precision , intent ( in ) :: x !! X-coordinate [m] double precision , intent ( in ) :: y !! Y-coordinate [m] double precision , intent ( in ) :: xc !! X-coordinate of the center on the polar grid double precision , intent ( in ) :: yc !! Y-coordinate of the center on the polar grid double precision , intent ( out ) :: r !! Radius [m] double precision , intent ( out ) :: t !! Angle [rad] double precision :: rx , ry rx = x - xc ry = y - yc r = dsqrt ( rx ** 2 + ry ** 2 ) if ( rx == 0.0d0 . and . ry == 0.0d0 ) then t = 0.0d0 else if ( rx == 0.0d0 . and . ry /= 0.0d0 ) then if ( ry > 0.0d0 ) then t = 0.5d0 * pi_dp else t = 1.5d0 * pi_dp end if else if ( rx /= 0.0d0 . and . ry == 0.0d0 ) then if ( rx > 0.0d0 ) then t = 0.0d0 else t = pi_dp end if else if ( rx > 0.0d0 . and . ry > 0.0d0 ) then t = datan ( ry / rx ) else if ( rx < 0.0d0 . and . ry > 0.0d0 ) then t = pi_dp - datan ( ry / dabs ( rx )) else if ( rx > 0.0d0 . and . ry < 0.0d0 ) then t = 2.0d0 * pi_dp - datan ( dabs ( ry ) / rx ) else if ( rx < 0.0d0 . and . ry < 0.0d0 ) then t = pi_dp + datan ( ry / rx ) end if end if end subroutine xy_2_rt !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine rt_2_xy ( r , t , x , y ) !! Convert the polar grid (r-t) to the Cartesian (x-y) grid (from STPK) implicit none double precision , intent ( in ) :: r !! Radius [m] double precision , intent ( in ) :: t !! Angle [rad] double precision , intent ( out ) :: x !! X-coordinate [m] double precision , intent ( out ) :: y !! Y-coordinate [m] x = r * dcos ( t ) y = r * dsin ( t ) end subroutine rt_2_xy !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine interpolation_2d ( x , y , z , point , val ) !! Perform bilinear interpolation to the \"point\" on the Cartesian (x-y) grid (from STPK) implicit none double precision , intent ( in ) :: x ( 2 ) !! The nearest west and east points for \"point\" double precision , intent ( in ) :: y ( 2 ) !! The nearest south and north points for \"point\" double precision , intent ( in ) :: z ( 2 , 2 ) !! Values defined at (x,y). !! z(1,1) at x(1), y(1) !! z(1,2) at x(1), y(2) !! z(2,1) at x(2), y(1) !! z(2,2) at x(2), y(2) double precision , intent ( in ) :: point ( 2 ) !! The target point for the interpolation double precision , intent ( out ) :: val !! Interpolated value ! internal variables double precision :: valx ( 2 ) call interpolation_1d ( x , ( / z ( 1 , 1 ), z ( 2 , 1 ) / ), point ( 1 ), valx ( 1 ) ) call interpolation_1d ( x , ( / z ( 1 , 2 ), z ( 2 , 2 ) / ), point ( 1 ), valx ( 2 ) ) call interpolation_1d ( y , valx , point ( 2 ), val ) end subroutine interpolation_2d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine interpolation_1d ( x , y , point , val ) !! Perform linear interpolation to the \"point\" on the Cartesian (x) grid (from STPK) implicit none double precision , intent ( in ) :: x ( 2 ) !! The nearest west and east points for \"point\" double precision , intent ( in ) :: y ( 2 ) !! Values defined at x. !! y(1) at x(1) !! y(2) at x(2) double precision , intent ( in ) :: point !! The target point for the interpolation double precision , intent ( out ) :: val !! Interpolated value ! internal variables double precision :: fd , dt double precision :: tmin double precision :: tmax double precision :: xmin double precision :: xmax tmin = x ( 1 ) tmax = x ( 2 ) xmin = y ( 1 ) xmax = y ( 2 ) dt = point - tmin fd = ( xmax - xmin ) / ( tmax - tmin ) val = xmin + dt * fd end subroutine interpolation_1d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine max_val_1d ( var , mamv , undef ) !! Get the max value (from STPK) implicit none double precision , intent ( in ) :: var (:) !! Searched array double precision , intent ( inout ) :: mamv !! Max value in var double precision , intent ( in ), optional :: undef !! undefined value integer :: nx integer :: i logical :: undeflag nx = size ( var ) undeflag = . true . if ( present ( undef )) then do i = 1 , nx if ( var ( i ) /= undef ) then if ( undeflag . eqv .. true .) then undeflag = . false . mamv = dabs ( var ( i )) else if ( dabs ( var ( i )) > mamv ) then mamv = dabs ( var ( i )) end if end if end if end do if ( undeflag . eqv .. true .) then mamv = undef end if else mamv = dabs ( var ( 1 )) do i = 2 , nx if ( dabs ( var ( i )) > mamv ) then mamv = dabs ( var ( i )) end if end do end if end subroutine max_val_1d !-------------------------------------------------------------- !-------------------------------------------------------------- subroutine stand_devi ( x , true_val , anor , undef ) !! Calculate RMSE of x for the \"true_val\" (from STPK) <br> !! Definition: RMSE = \\sqrt{\\sum&#94;{N}_{i=1}{(1/N)(x(i)-x_t)&#94;2}},  <br> !!             x_t=\\mathrm{true\\_val}  implicit none double precision , intent ( in ) :: x (:) !! sampling data double precision , intent ( in ) :: true_val !! reference data double precision , intent ( out ) :: anor !! RMSE double precision , intent ( in ), optional :: undef !! missing value integer :: i integer :: nx ! data number integer :: nt double precision :: anorval nx = size ( x ) anorval = 0.0d0 if ( present ( undef )) then nt = 0 do i = 1 , nx if ( x ( i ) /= undef ) then anorval = anorval + ( x ( i ) - true_val ) ** 2 nt = nt + 1 end if end do if ( anorval /= undef . and . nt /= 0 ) then anorval = dsqrt ( anorval / dble ( nt )) end if else do i = 1 , nx anorval = anorval + ( x ( i ) - true_val ) ** 2 end do anorval = dsqrt ( anorval / dble ( nx )) end if anor = anorval end subroutine stand_devi !-------------------------------------------------------------- !-------------------------------------------------------------- end module GVTDX_sub","tags":"","loc":"sourcefile/sub_mod.f90.html"},{"title":"gbvtd_main_mod.f90 – GVTD-HeCs","text":"This file depends on sourcefile~~gbvtd_main_mod.f90~~EfferentGraph sourcefile~gbvtd_main_mod.f90 gbvtd_main_mod.f90 sourcefile~sub_mod.f90 sub_mod.f90 sourcefile~gbvtd_main_mod.f90->sourcefile~sub_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GBVTD_main Source Code gbvtd_main_mod.f90 Source Code module GBVTD_main !! The main module of GBVTD based on Lee et al. (1999, MWR) use GVTDX_sub implicit none public :: Retrieve_velocity_GBVTD private :: calc_fkj private :: calc_fkj2akp private :: calc_fkjVd2bk private :: set_xk2variables private :: calc_AB2VT private :: calc_Vn2Vtot private :: check_zero private :: check_undef_grid private :: set_undef_value contains subroutine Retrieve_velocity_GBVTD ( nasym , r , t , td , Vd , Un , Vn , RadTC , & & VT , VR , VT0 , VR0 , VTSn , VTCn , undef ) !!  Solve unknown variables and return wind velocity on R-T coordinates !!  based on the GBVTD technique. <br> !!------------------------------------------------------ <br> !!  [relationship between r and rh] -- <br> !!------------------------------------------------------ <br> !!    i-1    i    i+1 <br> !!  ...|-- --|-- --|... : r(1:size(r)) = velocity radii <br> !!------------------------------------------------------ implicit none !-- input/output integer , intent ( in ) :: nasym !! wave number for asymmetric tangential wind double precision , intent ( in ) :: r (:) !! radial coordinate on which Vd is defined [m] double precision , intent ( in ) :: t (:) !! azimuthal coordinate on which Vd is defined [rad] double precision , intent ( in ) :: td ( size ( r ), size ( t )) !! radar azimuthal angle defined at Vd(r,t) [rad] double precision , intent ( inout ) :: Vd ( size ( r ), size ( t )) !! Doppler velocity defined on r-t [m s-1] double precision , intent ( in ) :: Un ( 2 ) !! Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: Vn ( 2 ) !! Normal component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: RadTC !! Distance from radar to TC center [m] double precision , intent ( out ) :: VT ( size ( r ), size ( t )) !! retrieved total tangential wind [m s-1] double precision , intent ( out ) :: VR ( size ( r ), size ( t )) !! retrieved total radial wind [m s-1] double precision , intent ( out ) :: VT0 ( size ( r ), size ( t )) !! retrieved axisymmetric radial component of rotating wind [m s-1] double precision , intent ( out ) :: VR0 ( size ( r ), size ( t )) !! retrieved axisymmetric tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VTSn ( nasym , size ( r ), size ( t )) !! retrieved tangential component of rotating wind [m s-1] double precision , intent ( out ) :: VTCn ( nasym , size ( r ), size ( t )) !! retrieved radial component of rotating wind [m s-1] double precision , intent ( in ), optional :: undef !! undefined value for Vd !-- internal variables integer :: i , j , k , p , cstat ! dummy indexes integer :: nr , nt ! array numbers for r and t, respectively integer :: nk ! array number of a_k integer :: nr_out ! outermost radius for GBVTD limit radius double precision , allocatable , dimension (:,:) :: x_k ! unknown vector for retrieved coefficients double precision , allocatable , dimension (:,:) :: b_k ! known vector given by observed values double precision , allocatable , dimension (:,:,:) :: a_kp ! coefficient matrix for x_k double precision , allocatable , dimension (:,:,:) :: f_kj ! a_kp = sum_{j}(f_kj * f_pj) double precision , allocatable , dimension (:) :: Vd_A0 ! Results for wavenumber-0 of Vd double precision , allocatable , dimension (:,:) :: Vd_AC ! Results for cosine components of Vd double precision , allocatable , dimension (:,:) :: Vd_BS ! Results for sine components of Vd double precision , allocatable , dimension (:,:) :: psid ! nonlinear angle double precision , allocatable , dimension (:) :: td_max ! Max of td double precision :: dundef , vmax double precision , dimension ( size ( r )) :: r_n ! Nondimensional r double precision :: rtc_n ! Nondimensional RadTC logical , allocatable , dimension (:,:) :: undeflag ! Flag for Vd grid with undef !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"Retrieve_velocity_GBVTD\" , 0 ) nr = size ( r ) nt = size ( t ) vmax = 5 0.0d0 if ( present ( undef )) then dundef = undef else dundef =- 1.0d35 end if VT = dundef VR = dundef VT0 = dundef VR0 = dundef VTSn = dundef VTCn = dundef !-- Check retrieved asymmetric wave number if ( nasym < 0 ) then call stdout ( \"nasym is greater equal to 0. stop.\" , \"Retrieve_velocity_GBVTD\" , - 1 ) stop end if nk = 1 + 2 * ( nasym + 1 ) !-- Normalized r r_n = r / r ( nr ) rtc_n = RadTC / r ( nr ) nr_out = nr do i = 1 , nr if ( r_n ( i ) >= rtc_n ) then nr_out = i - 1 exit end if end do !-- Allocate and initialize arrays ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( Vd_A0 ( ompnum ), stat = cstat ) allocate ( Vd_AC ( nasym + 1 , ompnum ), stat = cstat ) allocate ( Vd_BS ( nasym + 1 , ompnum ), stat = cstat ) allocate ( x_k ( nk , ompnum ), stat = cstat ) allocate ( b_k ( nk , ompnum ), stat = cstat ) allocate ( a_kp ( nk , nk , ompnum ), stat = cstat ) allocate ( f_kj ( nk , nt , ompnum ), stat = cstat ) allocate ( psid ( nt , ompnum ), stat = cstat ) allocate ( td_max ( ompnum ), stat = cstat ) allocate ( undeflag ( nr , nt ), stat = cstat ) undeflag = . false . call check_undef_grid ( Vd , dundef , undeflag ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"Retrieve_velocity_GBVTD\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(i,omppe) do i = 1 , nr_out !$   omppe=OMP_GET_THREAD_NUM()+1 x_k ( 1 : nk , omppe ) = 0.0d0 b_k ( 1 : nk , omppe ) = 0.0d0 a_kp ( 1 : nk , 1 : nk , omppe ) = 0.0d0 f_kj ( 1 : nk , 1 : nt , omppe ) = 0.0d0 Vd_A0 ( omppe ) = 0.0d0 Vd_AC ( 1 : nasym + 1 , omppe ) = 0.0d0 Vd_BS ( 1 : nasym + 1 , omppe ) = 0.0d0 psid ( 1 : nt , omppe ) = 0.0d0 call check_max ( td ( i , 1 : nt ), td_max ( omppe ) ) !-- Calculate the nonlinear angle psid call calc_psid ( rtc_n , r_n ( i ), t , td ( i , 1 : nt ), psid ( 1 : nt , omppe ) ) !-- Calculate f_kj call calc_fkj ( nasym , nk , psid ( 1 : nt , omppe ), & & f_kj ( 1 : nk , 1 : nt , omppe ), undeflag ( i , 1 : nt ) ) !-- Calculate b_k call calc_fkjVd2bk ( vmax , f_kj ( 1 : nk , 1 : nt , omppe ), Vd ( i , 1 : nt ), & & b_k ( 1 : nk , omppe ), undeflag ( i , 1 : nt ) ) !-- Calculate a_kp call calc_fkj2akp ( f_kj ( 1 : nk , 1 : nt , omppe ), a_kp ( 1 : nk , 1 : nk , omppe ), undeflag ( i , 1 : nt ) ) call check_zero ( a_kp ( 1 : nk , 1 : nk , omppe ) ) !-- Solve x_k !  call tri_gauss( a_kp, b_k, x_k ) !  call gausss( a_kp, b_k, x_k ) call fp_gauss ( a_kp ( 1 : nk , 1 : nk , omppe ), b_k ( 1 : nk , omppe ), x_k ( 1 : nk , omppe ) ) !-- Set each unknown variable from x_k call set_xk2variables ( nasym , nk , x_k ( 1 : nk , omppe ), Vd_A0 ( omppe ), & & Vd_AC ( 1 : nasym + 1 , omppe ), Vd_BS ( 1 : nasym + 1 , omppe ), & & undef = dundef ) !-- Calculate Vr and Vt components of rotating wind call calc_AB2VT ( nasym , vmax , r_n ( i ), td_max ( omppe ), Vn ( 1 ), psid ( 1 : nt , omppe ), rtc_n , & & Vd_A0 ( omppe ), Vd_AC ( 1 : nasym + 1 , omppe ), Vd_BS ( 1 : nasym + 1 , omppe ), & & VT0 ( i , 1 : nt ), VR0 ( i , 1 : nt ), VTSn ( 1 : nasym , i , 1 : nt ), VTCn ( 1 : nasym , i , 1 : nt ), & & undef = dundef ) end do !$omp end do !$omp end parallel !-- Calculate total retrieved Vr and Vt call calc_Vn2Vtot ( nasym , VT0 , VTSn , VTCn , VT , undef = dundef ) VR = VR0 !-- Set undef in each output variable at undefined grids call set_undef_value ( undeflag , dundef , VT ) call set_undef_value ( undeflag , dundef , VR ) if ( nasym > 0 ) then do k = 1 , nasym call set_undef_value ( undeflag , dundef , VTSn ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VTCn ( k , 1 : nr , 1 : nt ) ) end do end if call stdout ( \"Finish procedure.\" , \"Retrieve_velocity_GBVTD\" , 0 ) end subroutine Retrieve_velocity_GBVTD subroutine calc_fkj ( nasym , nnk , psid , fkj , undeflag ) !! Calculate the coefficient matrix f_{kj} implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components integer , intent ( in ) :: nnk !! Matrix dimension for fkj double precision , intent ( in ) :: psid (:) !! Nonlinear angle \\psi _d [rad] double precision , intent ( out ) :: fkj ( nnk , size ( psid )) !! Coefficient matrix logical , intent ( in ) :: undeflag ( size ( psid )) !! Undefined flag at each sampling point !-- internal variables integer :: nmax , nnt , jj , kk , cstat double precision , dimension ( nasym + 1 , size ( psid )) :: sinen , cosinen call stdout ( \"Enter procedure.\" , \"calc_fkj\" , 0 ) nnt = size ( psid ) fkj = 0.0d0 nmax = nasym + 1 sinen = 0.0d0 cosinen = 0.0d0 if ( nnk /= 1 + 2 * ( nasym + 1 )) then call stdout ( \"nnk is not 1+2(nasym+1). stop.\" , \"calc_fkj\" , - 1 ) stop end if !-- Set fixed variables for R-T, in advance do jj = 1 , nnt do kk = 1 , nmax sinen ( kk , jj ) = dsin ( dble ( kk ) * psid ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * psid ( jj )) end do end do !-- Set coefficients for A0 at each (jj) fkj ( 1 , 1 : nnt ) = 1.0d0 !-- Set coefficients for A1 to An and B1 to Bn at each (jj) do jj = 1 , nnt do kk = 1 , nmax fkj ( 1 + kk , jj ) = cosinen ( kk , jj ) fkj ( 1 + nmax + kk , jj ) = sinen ( kk , jj ) end do end do call stdout ( \"Finish procedure.\" , \"calc_fkj\" , 0 ) end subroutine calc_fkj subroutine calc_fkj2akp ( fkj , akp , undeflag ) !! Calculate a_kp from f_kj implicit none double precision , intent ( in ) :: fkj (:,:) !! Coefficient matrix double precision , intent ( out ) :: akp ( size ( fkj , 1 ), size ( fkj , 1 )) !! Coefficient matrix in LSM logical , intent ( in ) :: undeflag ( size ( fkj , 2 )) !! Undefined flag at each sampling point integer :: nnk , nnj , jj , kk , ll , cstat call stdout ( \"Enter procedure.\" , \"calc_fkj2akp\" , 0 ) nnk = size ( fkj , 1 ) nnj = size ( fkj , 2 ) do ll = 1 , nnk do kk = ll , nnk akp ( kk , ll ) = matrix_sum ( fkj ( kk , 1 : nnj ), fkj ( ll , 1 : nnj ), & & undeflag ( 1 : nnj ) ) akp ( ll , kk ) = akp ( kk , ll ) end do end do call stdout ( \"Finish procedure.\" , \"calc_fkj2akp\" , 0 ) end subroutine calc_fkj2akp subroutine calc_fkjVd2bk ( vmax , fkj , Vdl , bk , undeflag ) !! Calculate b_k from f_{k,j} and V_d implicit none double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: fkj (:,:) !! Coefficient matrix double precision , intent ( in ) :: Vdl ( size ( fkj , 2 )) !! Doppler velocity [m/s] double precision , intent ( out ) :: bk ( size ( fkj , 1 )) !! Vector \\textbf{b}  logical , intent ( in ) :: undeflag ( size ( fkj , 2 )) !! Undefined flag at each sampling point integer :: nnk , nnj , jj , kk , ll , cstat double precision :: dVdl ( size ( fkj , 2 )) call stdout ( \"Enter procedure.\" , \"calc_fkjVd2bk\" , 0 ) nnk = size ( fkj , 1 ) nnj = size ( fkj , 2 ) dVdl ( 1 : nnj ) = Vdl ( 1 : nnj ) do kk = 1 , nnk bk ( kk ) = matrix_sum ( dVdl ( 1 : nnj ), fkj ( kk , 1 : nnj ), & & undeflag ( 1 : nnj ) ) / vmax end do call stdout ( \"Finish procedure.\" , \"calc_fkjVd2bk\" , 0 ) end subroutine calc_fkjVd2bk subroutine set_xk2variables ( nasym , nnk , xk , A0 , ACn , BSn , undef ) !! Set each unknown variable from x_k implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components integer , intent ( in ) :: nnk !! Matrix dimension for coefficient matrix A double precision , intent ( in ) :: xk ( nnk ) !! solved unknown variable vector double precision , intent ( out ) :: A0 !! Wavenumber-0 for Doppler velocity double precision , intent ( out ) :: ACn ( nasym + 1 ) !! Cosine conponents of Doppler velocity double precision , intent ( out ) :: BSn ( nasym + 1 ) !! Sine components of Doppler velocity double precision , intent ( in ), optional :: undef !! Undefined value integer :: kk call stdout ( \"Enter procedure.\" , \"set_xk2variables\" , 0 ) A0 = xk ( 1 ) do kk = 1 , nasym + 1 ACn ( kk ) = xk ( 1 + kk ) BSn ( kk ) = xk ( 1 + nasym + 1 + kk ) end do call stdout ( \"Finish procedure.\" , \"set_xk2variables\" , 0 ) end subroutine set_xk2variables subroutine calc_AB2VT ( nasym , vmax , rd , thetad_max , Vn , psid , rtc , A0 , An , Bn , & & VT0_rt , VR0_rt , VTSn_rt , VTCn_rt , undef ) !! Calculate tangential components of retrieved wind implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rd !! Normalized radius [1] double precision , intent ( in ) :: thetad_max !! Normalized radius double precision , intent ( in ) :: Vn !! Normal component of environmental [ms-1] double precision , intent ( in ) :: psid (:) !! Nonlinear angle \\psi _d double precision , intent ( in ) :: rtc !! Normalized distance between the radar to vortex center [1] double precision , intent ( in ) :: A0 !! Wanvenumber-0 of Doppler velocity double precision , intent ( in ) :: An ( nasym + 1 ) !! Cosine components of Doppler velocity double precision , intent ( in ) :: Bn ( nasym + 1 ) !! Sine components of Doppler velocity double precision , intent ( out ) :: VT0_rt ( size ( psid )) !! Wavenumber-0 tangential wind double precision , intent ( out ) :: VR0_rt ( size ( psid )) !! Wavenumber-0 radial wind double precision , intent ( out ) :: VTSn_rt ( nasym , size ( psid )) !! Sine components of tangential wind [m/s] double precision , intent ( out ) :: VTCn_rt ( nasym , size ( psid )) !! Cosine components of tangential wind [m/s] double precision , intent ( in ), optional :: undef !! No use integer :: jj , kk , nnt , cstat double precision , dimension ( nasym , size ( psid )) :: cosinen , sinen double precision , dimension ( nasym ) :: VTSn_r , VTCn_r call stdout ( \"Enter procedure.\" , \"calc_AB2VT\" , 0 ) nnt = size ( psid ) do jj = 1 , nnt do kk = 1 , nasym cosinen ( kk , jj ) = dcos ( dble ( kk ) * psid ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * psid ( jj )) end do end do VT0_rt ( 1 : nnt ) =- ( Bn ( 1 ) + Bn ( 3 )) * vmax - Vn * dsin ( thetad_max ) VR0_rt ( 1 : nnt ) = ( An ( 1 ) + An ( 3 )) * vmax VTSn_r ( 1 ) = An ( 2 ) - A0 + An ( 4 ) + ( A0 + An ( 2 ) + An ( 4 )) * dcos ( thetad_max ) VTCn_r ( 1 ) =- 2.0d0 * ( Bn ( 2 ) + Bn ( 4 )) do kk = 2 , nasym VTSn_r ( kk ) = 2.0d0 * An ( kk + 1 ) VTCn_r ( kk ) =- 2.0d0 * Bn ( kk + 1 ) end do do jj = 1 , nnt do kk = 1 , nasym VTSn_rt ( kk , jj ) = VTSn_r ( kk ) * sinen ( kk , jj ) * vmax VTCn_rt ( kk , jj ) = VTCn_r ( kk ) * cosinen ( kk , jj ) * vmax end do end do call stdout ( \"Finish procedure.\" , \"calc_AB2VT\" , 0 ) end subroutine calc_AB2VT subroutine calc_Vn2Vtot ( nasym , V0 , VSn , VCn , Vtot , undef ) !! Calculate total wind from all wavenumbers implicit none integer , intent ( in ) :: nasym !! Maximum wavenumber for asymmetric components double precision , intent ( in ) :: V0 (:,:) !! Wavenumber-0 wind [m/s] double precision , intent ( in ) :: VSn ( nasym , size ( V0 , 1 ), size ( V0 , 2 )) !! Sine components of wnd [m/s] double precision , intent ( in ) :: VCn ( nasym , size ( V0 , 1 ), size ( V0 , 2 )) !! Cosine components of wind [m/s] double precision , intent ( inout ) :: Vtot ( size ( V0 , 1 ), size ( V0 , 2 )) !! Total wind [m/s] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , kk , nnr , nnt call stdout ( \"Enter procedure.\" , \"calc_Vn2Vtot\" , 0 ) nnr = size ( V0 , 1 ) nnt = size ( V0 , 2 ) Vtot = V0 if ( present ( undef )) then do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nasym if ( VSn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + VSn ( kk , ii , jj ) end if if ( VCn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + VCn ( kk , ii , jj ) end if end do end do end do else do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nasym Vtot ( ii , jj ) = Vtot ( ii , jj ) + VSn ( kk , ii , jj ) + VCn ( kk , ii , jj ) end do end do end do end if call stdout ( \"Finish procedure.\" , \"calc_VSn2Vtot\" , 0 ) end subroutine calc_Vn2Vtot subroutine calc_psid ( rtc , r , theta , thetad , psid ) !! Calculate the nonlinear angle psid at a centain radius <br> !! From the geometry, <br> !! \\sin{\\psi_d} = (R_{TC}/r) \\sin{\\theta _d}. --(1) <br> !! R&#94;2_{TC} = r&#94;2 + D&#94;2 - 2rD\\cos{\\psi_d} , D=r\\dfrac{\\sin{\\theta}}{\\sin{\\theta _d}}. --(2) <br> !! From Eq. (2), <br> !! \\cos{\\psi_d} = (r&#94;2 + D&#94;2 - R_{TC}&#94;2) / (2rD). --(3) <br> !! From Eqs. (1) and (3), <br> !! \\tan{\\psi_d} = 2\\rho \\dfrac{\\sin{\\theta}}{\\rho &#94;2+a\\rho &#94;2-1},  <br> !!  \\rho =r/R_{TC}, a=\\dfrac{\\sin{\\theta}}{\\sin{\\theta _d}} .  implicit none double precision , intent ( in ) :: rtc !! Distance from the radar to TC center [m] double precision , intent ( in ) :: r !! Radius [m] double precision , intent ( in ) :: theta (:) !! azimuthal angle [deg] double precision , intent ( in ) :: thetad ( size ( theta )) !! Azimuthal angle for radar [rad] double precision , intent ( out ) :: psid ( size ( theta )) !! Nonlinear angle \\psi _d [rad] integer :: jj , nnt double precision :: x , y , rpp call stdout ( \"Enter procedure.\" , \"calc_psid\" , 0 ) nnt = size ( theta ) rpp = r / rtc do jj = 1 , nnt if ( dsin ( thetad ( jj )) == 0.0d0 ) then ! In this case, theta = psid psid ( jj ) = theta ( jj ) else x = ( rpp ** 2 ) * ( 1.0d0 + ( dsin ( theta ( jj )) / dsin ( thetad ( jj ))) ** 2 ) - 1.0d0 y = 2.0d0 * rpp * dsin ( theta ( jj )) psid ( jj ) = datan2 ( y , x ) end if end do call stdout ( \"Finish procedure.\" , \"calc_psid\" , 0 ) end subroutine calc_psid double precision function matrix_sum ( aij , akj , undeflag ) !! Calculate product for a component in a matrix implicit none double precision , intent ( in ) :: aij (:) !! Matrix A1 double precision , intent ( in ) :: akj ( size ( aij )) !! Matrix A2 logical , intent ( in ), optional :: undeflag ( size ( aij )) !! Undefined flag at each sampling point integer :: jj , nj double precision :: res nj = size ( aij ) res = 0.0d0 if ( present ( undeflag )) then do jj = 1 , nj if ( undeflag ( jj ). eqv .. false .) then res = res + aij ( jj ) * akj ( jj ) end if end do else do jj = 1 , nj res = res + aij ( jj ) * akj ( jj ) end do end if matrix_sum = res return end function matrix_sum subroutine check_max ( ival , mx_val ) !! Check maximum value in each element of the matrix \"a\" implicit none double precision , intent ( in ) :: ival (:) !! Matrix A double precision , intent ( out ) :: mx_val !! Max value in A integer :: ii , nni double precision :: res nni = size ( ival ) res = ival ( 1 ) do ii = 2 , nni res = max ( ival ( ii ), res ) end do mx_val = res end subroutine check_max subroutine check_zero ( a ) !! Check zero components in the matrix \"a\" implicit none double precision , intent ( in ) :: a (:,:) !! Matrix A integer :: ii , jj , nni , nnj logical :: res nni = size ( a , 1 ) nnj = size ( a , 2 ) do jj = 1 , nnj res = . false . do ii = 1 , nni if ( a ( ii , jj ) /= 0.0d0 ) then res = . true . exit end if end do if ( res . eqv .. false .) then write ( * , * ) \"Detect all zero\" , jj end if end do end subroutine check_zero subroutine check_undef_grid ( vval , undefv , undeflag ) !! Check undefined grids implicit none double precision , intent ( in ) :: vval (:,:) !! Grid value double precision , intent ( in ) :: undefv !! Undefined value logical , intent ( out ) :: undeflag ( size ( vval , 1 ), size ( vval , 2 )) ! Undefined flag integer :: ii , jj , nni , nnj nni = size ( vval , 1 ) nnj = size ( vval , 2 ) undeflag = . false . do jj = 1 , nnj do ii = 1 , nni if ( vval ( ii , jj ) == undefv ) then undeflag ( ii , jj ) = . true . end if end do end do end subroutine check_undef_grid subroutine set_undef_value ( undeflag , undefv , vval ) !! Set undef value (=\"undefv\") to val if undeflag == true. implicit none logical , intent ( in ) :: undeflag (:,:) !! Undefined flag at each sampling point double precision , intent ( in ) :: undefv !! Undefined value double precision , intent ( inout ) :: vval ( size ( undeflag , 1 ), size ( undeflag , 2 )) !! Original value at each sampling point integer :: ii , jj , nni , nnj nni = size ( undeflag , 1 ) nnj = size ( undeflag , 2 ) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then vval ( ii , jj ) = undefv end if end do end do end subroutine set_undef_value end module GBVTD_main","tags":"","loc":"sourcefile/gbvtd_main_mod.f90.html"},{"title":"gvtdx_main_mod2.f90 – GVTD-HeCs","text":"This file depends on sourcefile~~gvtdx_main_mod2.f90~~EfferentGraph sourcefile~gvtdx_main_mod2.f90 gvtdx_main_mod2.f90 sourcefile~sub_mod.f90 sub_mod.f90 sourcefile~gvtdx_main_mod2.f90->sourcefile~sub_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GVTDX_main2 Source Code gvtdx_main_mod2.f90 Source Code module GVTDX_main2 use GVTDX_sub implicit none public :: Retrieve_velocity2_GVTDX private :: calc_fkij private :: calc_fkij2akp private :: calc_fkijVd2bk private :: set_xk2variables private :: calc_phi2Vrot private :: calc_D2Vdiv private :: calc_Vn2Vtot private :: check_zero private :: check_undef_grid private :: set_undef_value private :: calc_Phi2Phin private :: calc_Phi2Zetan private :: calc_pseudo_GVTD0 private :: calc_phi2sc contains subroutine Retrieve_velocity2_GVTDX ( nrot , ndiv , r , t , rh , td , rdiv , Vd , Un , Vn , RadTC , & & VT , VR , VRT0 , VDR0 , VRTn , VRRn , VDTm , VDRm , & & undef , phin , zetan , VRT0_GVTD , VDR0_GVTD , & & VRTns , VRTnc , VRRns , VRRnc ) !-- solve unknown variables and return wind velocity on R-T coordinates. !------------------------------------------------------- !-- [relationship between r and rh] -- !------------------------------------------------------- !--   i-1    i    i+1 !-- ...|-- --|-- --|... : r(1:size(r)) = velocity radii !-- |-- --|-- --|-- --| : rh(1,size(r)+1) = potential radii !--i-1    i    i+1   i+2 !------------------------------------------------------- implicit none !-- input/output integer , intent ( in ) :: nrot ! wave number for rotating wind integer , intent ( in ) :: ndiv ! wave number for divergent wind double precision , intent ( in ) :: r (:) ! radial coordinate on which Vd is defined [m] double precision , intent ( in ) :: t (:) ! azimuthal coordinate on which Vd is defined [rad] double precision , intent ( in ) :: rh ( size ( r ) + 1 ) ! radial coordinate on which Phi (staggered for Vd) is defined [m] double precision , intent ( in ) :: td ( size ( r ), size ( t )) ! radar azimuthal angle defined at Vd(r,t) [rad] double precision , intent ( in ) :: rdiv (:) ! radial coordinate on which Dc (staggered for Vd) is defined [m] double precision , intent ( inout ) :: Vd ( size ( r ), size ( t )) ! Doppler velocity defined on r-t [m s-1] double precision , intent ( in ) :: Un ( 2 ) ! Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: Vn ( 2 ) ! Normal component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: RadTC ! Distance from radar to TC center [m] double precision , intent ( out ) :: VT ( size ( r ), size ( t )) ! retrieved total tangential wind [m s-1] double precision , intent ( out ) :: VR ( size ( r ), size ( t )) ! retrieved total radial wind [m s-1] double precision , intent ( out ) :: VRT0 ( size ( r ), size ( t )) ! retrieved axisymmetric radial component of rotating wind [m s-1] double precision , intent ( out ) :: VDR0 ( size ( r ), size ( t )) ! retrieved axisymmetric tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VRTn ( nrot , size ( r ), size ( t )) ! retrieved tangential component of rotating wind [m s-1] double precision , intent ( out ) :: VRRn ( nrot , size ( r ), size ( t )) ! retrieved radial component of rotating wind [m s-1] double precision , intent ( out ) :: VDTm ( ndiv , size ( r ), size ( t )) ! retrieved tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VDRm ( ndiv , size ( r ), size ( t )) ! retrieved radial component of divergent wind [m s-1] double precision , intent ( in ), optional :: undef ! undefined value for Vd double precision , intent ( out ), optional :: phin ( nrot , size ( r ), size ( t )) ! retrieved stream function [m2 s-1] double precision , intent ( out ), optional :: zetan ( nrot , size ( r ), size ( t )) ! retrieved vorticity [s-1] double precision , intent ( out ), optional :: VRT0_GVTD ( size ( r ), size ( t )) ! retrieved axisymmetric radial component of pseudo-GVTD tangential wind [m s-1] double precision , intent ( out ), optional :: VDR0_GVTD ( size ( r ), size ( t )) ! retrieved axisymmetric tangential component of pseudo-GVTD tangential wind [m s-1] double precision , intent ( out ), optional :: VRTns ( nrot , size ( r ), size ( t )) ! Sine component of retrieved asymmetric radial wind [m s-1] double precision , intent ( out ), optional :: VRTnc ( nrot , size ( r ), size ( t )) ! Cosine component of retrieved asymmetric radial wind [m s-1] double precision , intent ( out ), optional :: VRRns ( nrot , size ( r ), size ( t )) ! Sine component of retrieved asymmetric tangential wind [m s-1] double precision , intent ( out ), optional :: VRRnc ( nrot , size ( r ), size ( t )) ! Cosine component of retrieved asymmetric tangential wind [m s-1] !-- internal variables integer :: i , j , k , p , irad , cstat ! dummy indexes integer :: nr , nt ! array numbers for r and t, respectively integer :: nk ! array number of a_k integer :: nrdiv ! array number for rdiv integer :: nrdiv2 ! array number for rdiv_n integer :: nbound ! element number for variables related to the outermost radius (i.e., 2*nrot-1) double precision , allocatable , dimension (:) :: Vdivr_r ! axisymmetric divergent wind (VDR0(r)) double precision , allocatable , dimension (:) :: Vrott_r ! axisymmetric rotating wind (VRT0(r)) double precision , allocatable , dimension (:,:) :: phis_nr ! asymmetric (sine) stream function (Phi_S(n,r)) double precision , allocatable , dimension (:,:) :: phic_nr ! asymmetric (cosine) stream function (Phi_C(n,r)) double precision , allocatable , dimension (:,:) :: divc_mr ! asymmetric (cosine) stream function (D_C(n,r)) double precision , allocatable , dimension (:) :: GVTDU_r ! axisymmetric radial wind for pseudo-GVTD double precision , allocatable , dimension (:) :: GVTDV_r ! axisymmetric tangential wind for pseudo-GVTD double precision , allocatable , dimension (:,:) :: VRTns_r ! sine component of tangential wind double precision , allocatable , dimension (:,:) :: VRTnc_r ! cosine component of tangential wind double precision , allocatable , dimension (:,:) :: VRRns_r ! sine component of radial wind double precision , allocatable , dimension (:,:) :: VRRnc_r ! cosine component of radial wind double precision , allocatable , dimension (:) :: x_k ! unknown vector for retrieved coefficients double precision , allocatable , dimension (:) :: b_k ! known vector given by observed values double precision , allocatable , dimension (:,:) :: a_kp ! coefficient matrix for x_k double precision , allocatable , dimension (:,:,:) :: f_kij ! a_kp = sum_{i,j}(f_kij * f_pij) double precision :: dundef , vmax , tmprho double precision , dimension ( size ( r )) :: r_n ! Nondimensional r double precision , dimension ( size ( rh )) :: rh_n ! Nondimensional rh double precision , dimension ( size ( rdiv ) * 2 ) :: rdiv_n ! Nondimensional rdiv (internal variable) double precision :: rtc_n ! Nondimensional RadTC double precision , dimension ( size ( r ), size ( t )) :: delta ! delta_ij logical , allocatable , dimension (:,:) :: undeflag ! Flag for Vd grid with undef call stdout ( \"Enter procedure.\" , \"Retrieve_velocity2_GVTDX\" , 0 ) nr = size ( r ) nt = size ( t ) nrdiv = size ( rdiv ) nrdiv2 = size ( rdiv ) * 2 vmax = 5 0.0d0 if ( present ( undef )) then dundef = undef else dundef =- 1.0d35 end if VT = dundef VR = dundef VRT0 = dundef VDR0 = dundef VRTn = dundef VRRn = dundef VDTm = dundef VDRm = dundef delta = undef if ( present ( phin )) then phin = dundef end if if ( present ( zetan )) then zetan = dundef end if if ( present ( VRT0_GVTD )) then VRT0_GVTD = dundef allocate ( GVTDV_r ( nr ), stat = cstat ) end if if ( present ( VDR0_GVTD )) then VDR0_GVTD = dundef allocate ( GVTDU_r ( nr ), stat = cstat ) end if if ( present ( VRTns )) then VRTns = dundef VRTnc = dundef VRRns = dundef VRRnc = dundef allocate ( VRTns_r ( nrot , nr ), stat = cstat ) allocate ( VRTnc_r ( nrot , nr ), stat = cstat ) allocate ( VRRns_r ( nrot , nr ), stat = cstat ) allocate ( VRRnc_r ( nrot , nr ), stat = cstat ) end if !-- Check retrieved asymmetric wave number if ( nrot < 0 ) then call stdout ( \"nrot is greater equal to 0. stop.\" , \"Retrieve_velocity2_GVTDX\" , - 1 ) stop end if if ( ndiv < 0 ) then call stdout ( \"ndiv is greater equal to 0. stop.\" , \"Retrieve_velocity2_GVTDX\" , - 1 ) stop end if !-- Normalized r and rh r_n = r / rh ( nr + 1 ) rh_n = rh / rh ( nr + 1 ) rtc_n = RadTC / rh ( nr + 1 ) !-- Check and search divergent radii do i = 1 , nrdiv call interpo_search_1d ( rh , rdiv ( i ), irad ) if (( irad == nr + 1 ). and .( rh ( nr + 1 ) < rdiv ( i ))) then if ( ndiv > 0 ) then call stdout ( \"Detect out of range. stop.\" , \"Retrieve_velocity2_GVTDX\" , - 1 ) stop else ! Not use of rdiv call stdout ( \"Detect out of range.\" , \"Retrieve_velocity2_GVTDX\" , 1 ) irad = nr end if end if rdiv_n ( 2 * i - 1 ) = rh ( irad ) / rh ( nr + 1 ) rdiv_n ( 2 * i ) = rh ( irad + 1 ) / rh ( nr + 1 ) end do !-- Calculate delta_ij !$omp parallel default(shared) !$omp do schedule(runtime) private(i,j,tmprho) do j = 1 , nt do i = 1 , nr if ( rtc_n > 0.0d0 ) then tmprho = r_n ( i ) / rtc_n delta ( i , j ) = dsqrt ( tmprho ** 2 + 2.0d0 * tmprho * dcos ( t ( j )) + 1.0d0 ) end if end do end do !$omp end do !$omp end parallel !-- Set total number for unknown variables in a_k if ( nrot > 0 ) then !-- nk = free variable + boundary variable (=nbound) !-- all arrays and matrices are composed of nk + nbound !-- The last \"nbound\" is asigned for \"lambda\" (i.e., additional constraints) nk = ( 2 + 2 * nrot ) * ( nr - 1 ) + 2 + 2 + ndiv * nrdiv + ( 2 * nrot - 1 ) nbound = 2 * nrot - 1 else nk = 2 * ( nr - 1 ) + 2 + ndiv * nrdiv nbound = 0 end if !-- Allocate and initialize arrays allocate ( Vdivr_r ( nr ), stat = cstat ) allocate ( Vrott_r ( nr ), stat = cstat ) allocate ( phis_nr ( nrot , nr + 1 ), stat = cstat ) allocate ( phic_nr ( nrot , nr + 1 ), stat = cstat ) allocate ( divc_mr ( ndiv , nrdiv ), stat = cstat ) allocate ( x_k ( nk + nbound ), stat = cstat ) allocate ( b_k ( nk + nbound ), stat = cstat ) allocate ( a_kp ( nk + nbound , nk + nbound ), stat = cstat ) allocate ( f_kij ( nk , nr , nt ), stat = cstat ) allocate ( undeflag ( nr , nt ), stat = cstat ) undeflag = . false . call check_undef_grid ( Vd , dundef , undeflag ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"Retrieve_velocity2_GVTDX\" , - 1 ) stop end if Vdivr_r = 0.0d0 Vrott_r = 0.0d0 phis_nr = 0.0d0 phic_nr = 0.0d0 divc_mr = 0.0d0 x_k = 0.0d0 b_k = 0.0d0 a_kp = 0.0d0 f_kij = 0.0d0 !-- Calculate f_kij !-- ** normalized radius is used in r_n ** call calc_fkij ( nrot , ndiv , nk , Un , Vn , rtc_n , r_n , t , rh_n , td , rdiv_n , f_kij , Vd , undeflag ) !-- Calculate b_k call calc_fkijVd2bk ( vmax , f_kij , Vd , delta , b_k ( 1 : nk ), undeflag ) !-- Calculate a_kp call calc_fkij2akp ( f_kij , a_kp ( 1 : nk , 1 : nk ), undeflag ) call check_zero ( a_kp ( 1 : nk , 1 : nk ) ) !-- Set elements for additional constraints if ( nrot > 0 ) then do k = 1 , nbound a_kp ( nk + k , nk - nbound + k ) = 1.0d0 a_kp ( nk - nbound + k , nk + k ) = 1.0d0 end do b_k ( nk + 1 ) =- rh_n ( nr ) * ( Vn ( 2 ) - Vn ( 1 )) / vmax end if !-- Solve x_k call fp_gauss ( a_kp , b_k , x_k ) !-- Set each unknown variable from x_k call set_xk2variables ( nrot , ndiv , nrdiv , Un , Vn , vmax , & & x_k ( 1 : nk ), Vrott_r , Vdivr_r , & & phis_nr , phic_nr , divc_mr , undef = dundef ) !-- Calculate Vr and Vt components of rotating wind call calc_phi2Vrot ( nrot , Un , Vn , vmax , r_n , rh_n , t , & & Vrott_r , VRT0 , VRTn , VRRn , phis_nr , phic_nr , & & undef = dundef ) !-- Calculate Vr and Vt components of divergent wind call calc_D2Vdiv ( ndiv , vmax , r_n , rh_n , t , rdiv_n , Vdivr_r , & & VDR0 , VDTm , VDRm , divc_mr , undef = dundef ) !-- Calculate total retrieved Vr and Vt call calc_Vn2Vtot ( nrot , ndiv , VRT0 , VRTn , VDTm , VT ) call calc_Vn2Vtot ( nrot , ndiv , VDR0 , VRRn , VDRm , VR ) !-- Set undef in each output variable at undefined grids call set_undef_value ( undeflag , dundef , VT ) call set_undef_value ( undeflag , dundef , VR ) if ( nrot > 0 ) then do k = 1 , nrot call set_undef_value ( undeflag , dundef , VRTn ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VRRn ( k , 1 : nr , 1 : nt ) ) end do end if if ( ndiv > 0 ) then do k = 1 , ndiv call set_undef_value ( undeflag , dundef , VDTm ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VDRm ( k , 1 : nr , 1 : nt ) ) end do end if !-- monitor variables if (( present ( phin )). and .( nrot > 0 )) then call calc_Phi2Phin ( nrot , vmax , rh ( nr + 1 ), r_n , rh_n , t , phis_nr , phic_nr , phin ) end if if (( present ( zetan )). and .( nrot > 0 )) then call calc_Phi2Zetan ( nrot , vmax , rh ( nr + 1 ), r_n , rh_n , t , phis_nr , phic_nr , zetan ) end if if ( present ( VRT0_GVTD ). and .( nrot > 0 )) then call calc_pseudo_GVTD0 ( nrot , vmax , rtc_n , r_n , rh_n , VRT0 ( 1 : nr , 1 ), VDR0 ( 1 : nr , 1 ), & & phis_nr , phic_nr , GVTDV_r ( 1 : nr ), GVTDU_r ( 1 : nr ) ) do i = 1 , nr VRT0_GVTD ( i , 1 : nt ) = GVTDV_r ( i ) VDR0_GVTD ( i , 1 : nt ) = GVTDU_r ( i ) end do end if if ( present ( VRTns ). and .( nrot > 0 )) then call calc_phi2sc ( nrot , vmax , r_n , rh_n , phis_nr , phic_nr , & & VRTns_r ( 1 : nrot , 1 : nr ), VRTnc_r ( 1 : nrot , 1 : nr ), & & VRRns_r ( 1 : nrot , 1 : nr ), VRRnc_r ( 1 : nrot , 1 : nr ) ) do k = 1 , nrot do i = 1 , nr VRTns ( k , i , 1 : nt ) = VRTns_r ( k , i ) VRTnc ( k , i , 1 : nt ) = VRTnc_r ( k , i ) VRRns ( k , i , 1 : nt ) = VRRns_r ( k , i ) VRRnc ( k , i , 1 : nt ) = VRRnc_r ( k , i ) end do end do end if call stdout ( \"Finish procedure.\" , \"Retrieve_velocity2_GVTDX\" , 0 ) end subroutine Retrieve_velocity2_GVTDX !-------------------------------------------------- !-- calculate f_kij !-------------------------------------------------- subroutine calc_fkij ( nrot , ndiv , nnk , Usrn , Vsrn , rtc , rd , theta , rdh , thetad , rddiv , & & fkij , Vdij , undeflag ) implicit none integer , intent ( in ) :: nrot integer , intent ( in ) :: ndiv integer , intent ( in ) :: nnk double precision , intent ( in ) :: Usrn ( 2 ) double precision , intent ( in ) :: Vsrn ( 2 ) double precision , intent ( in ) :: rtc double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: theta (:) double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) ! Normalized radius double precision , intent ( in ) :: thetad ( size ( rd ), size ( theta )) double precision , intent ( in ) :: rddiv (:) ! Normalized radius double precision , intent ( out ) :: fkij ( nnk , size ( rd ), size ( theta )) double precision , intent ( inout ) :: Vdij ( size ( rd ), size ( theta )) logical , intent ( in ) :: undeflag ( size ( rd ), size ( theta )) !-- internal variables integer :: nnr , nnt , nnrdiv , nnrdiv2 , ii , jj , kk , pp , nmax , cstat , ncyc double precision :: r1_out_coef !MOD, r_infty double precision , dimension ( size ( rd )) :: dr , dr_inv , alp double precision , dimension ( size ( rd )) :: r_inv double precision , dimension ( size ( rd ), size ( theta )) :: sines , cosines double precision , allocatable , dimension (:,:) :: sinen , cosinen double precision , allocatable , dimension (:,:,:) :: gkrr call stdout ( \"Enter procedure.\" , \"calc_fkij\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) nnrdiv2 = size ( rddiv ) nnrdiv = nnrdiv2 / 2 ncyc = 2 + 2 * nrot ! unknown variable number at a certain radius nmax = max ( max ( 0 , nrot ), ndiv ) ! maximum wave number for rotating and divergent components fkij = 0.0d0 if ( nmax > 0 ) then allocate ( sinen ( nmax , nnt ), stat = cstat ) allocate ( cosinen ( nmax , nnt ), stat = cstat ) allocate ( gkrr ( nmax , nnrdiv2 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rd if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkij\" , - 1 ) stop end if sinen = 0.0d0 cosinen = 0.0d0 gkrr = 0.0d0 end if if ( nrot > 0 ) then if ( nnk /= ncyc * ( nnr - 1 ) + 2 + 2 + ndiv * nnrdiv + 2 * nrot - 1 ) then call stdout ( \"nnk is not identical to (2+2N)(m-1)+2+2+M*(mm-1). stop.\" , \"calc_fkij\" , - 1 ) stop end if else if ( nnk /= ncyc * ( nnr - 1 ) + 2 + ndiv * nnrdiv ) then call stdout ( \"nnk is not identical to (2+2N)(m-1)+2+M*(mm-1). stop.\" , \"calc_fkij\" , - 1 ) stop end if end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) r_inv ( ii ) = 1.0d0 / rd ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !-- Set fixed variables for R-T, in advance !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr sines ( ii , jj ) = dsin ( theta ( jj )) ! MOD = (delta/rho) x sin(theta-thetad) cosines ( ii , jj ) = rd ( ii ) / rtc + dcos ( theta ( jj )) ! MOD = (delta/rho) x cos(theta-thetad) end do end do !$omp end do !$omp barrier if ( nmax > 0 ) then !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , nmax sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnrdiv2 ! For rdiv do kk = 1 , nmax gkrr ( kk , ii , jj ) = green_func ( rddiv ( ii ), rd ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnrdiv2 ! For rddiv do kk = 1 , nmax gkrr ( kk , ii , nnr + 1 ) = green_func ( rddiv ( ii ), rd ( nnr ) + dr ( nnr ), kk ) end do end do !$omp end do end if !$omp barrier !-- Set coefficients for VRT0 at each (ii,jj) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr fkij ( 1 + ncyc * ( ii - 1 ), ii , jj ) =- sines ( ii , jj ) end do end do !$omp end do !$omp barrier !-- Set coefficients for VDR0 at each (ii,jj) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr fkij ( 2 + ncyc * ( ii - 1 ), ii , jj ) = cosines ( ii , jj ) end do end do !$omp end do !$omp barrier if ( nrot > 0 ) then !-- Set coefficients for Phi_s and Phi_c at each (ii,jj) for wavenumber 1 !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr - 2 !-- Phi(s)*delta(s,i) fkij ( 2 + 1 + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( 1 , jj )) & & * ( - sines ( ii , jj )) & & + (( 1.0d0 - alp ( ii )) * dble ( 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i) fkij ( 2 + nrot + 1 + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( 1 , jj )) & & * ( - sines ( ii , jj )) & & - (( 1.0d0 - alp ( ii )) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(s)*delta(s,i+1) fkij ( 2 + 1 + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( 1 , jj )) & & * ( sines ( ii , jj )) & & + ( alp ( ii ) * dble ( 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i+1) fkij ( 2 + nrot + 1 + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( 1 , jj )) & & * ( sines ( ii , jj )) & & - ( alp ( ii ) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) end do end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c !--     at one inner radius from the outermost (nnr-1,jj) for wavenumber 1 !$omp do schedule(runtime) private(jj) do jj = 1 , nnt !-- Phi(s)*delta(s,nnr-2) fkij ( 2 + 1 + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( 1 , jj )) * ( - sines ( nnr - 1 , jj )) & & + (( 1.0d0 - alp ( nnr - 1 )) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr-2) fkij ( 2 + nrot + 1 + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( 1 , jj )) * ( - sines ( nnr - 1 , jj )) & & - (( 1.0d0 - alp ( nnr - 1 )) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + 1 + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( 1 , jj )) * ( sines ( nnr - 1 , jj )) & & + ( alp ( nnr - 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr-1) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + 1 + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( 1 , jj )) * ( sines ( nnr - 1 , jj )) & & - ( alp ( nnr - 1 ) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c !--     at the outermost (nnr,jj) for wavenumber 1 !$omp do schedule(runtime) private(jj) do jj = 1 , nnt !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + 1 + ncyc * ( nnr - 1 ), nnr , jj ) & & = ( dr_inv ( nnr ) * sinen ( 1 , jj )) * ( - sines ( nnr , jj )) & & + (( 1.0d0 - alp ( nnr )) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr ) * cosines ( nnr , jj )) !-- Phi(s)*delta(s,nnr) fkij ( 2 + 2 + ncyc * ( nnr - 1 ), nnr , jj ) & & = ( dr_inv ( nnr ) * sinen ( 1 , jj )) * ( sines ( nnr , jj )) & & + ( alp ( nnr ) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr ) * cosines ( nnr , jj )) if ( undeflag ( nnr , jj ). eqv .. false .) then ! Remove WN-1 Vm at the outermost radius Vdij ( nnr , jj ) & & = Vdij ( nnr , jj ) & & - ( Vsrn ( 2 ) - Vsrn ( 1 )) * ( - cosinen ( 1 , jj ) * sines ( nnr , jj ) & & + sinen ( 1 , jj ) * cosines ( nnr , jj )) end if end do !$omp end do !$omp barrier !-- 2. For wavenumber >= 2 if ( nrot > 1 ) then !-- Set coefficients for Phi_s and Phi_c at each (ii,jj) !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr - 2 do kk = 2 , nrot !-- Phi(s)*delta(s,i) fkij ( 2 + kk + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( kk , jj )) & & * ( - sines ( ii , jj )) & & + (( 1.0d0 - alp ( ii )) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i) fkij ( 2 + nrot + kk + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( kk , jj )) & & * ( - sines ( ii , jj )) & & - (( 1.0d0 - alp ( ii )) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(s)*delta(s,i+1) fkij ( 2 + kk + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( kk , jj )) & & * ( sines ( ii , jj )) & & + ( alp ( ii ) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i+1) fkij ( 2 + nrot + kk + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( kk , jj )) & & * ( sines ( ii , jj )) & & - ( alp ( ii ) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) end do end do end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c at one inner radius from the outermost (nnr-1,jj) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 2 , nrot !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + kk + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & =- dr_inv ( nnr - 1 ) * sinen ( kk , jj ) * sines ( nnr - 1 , jj ) & & + ( 1.0d0 - alp ( nnr - 1 )) * dble ( kk ) * cosinen ( kk , jj ) & & * r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj ) !-- Phi(c)*delta(s,nnr-1) fkij ( 2 + nrot + kk + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & =- dr_inv ( nnr - 1 ) * cosinen ( kk , jj ) * sines ( nnr - 1 , jj ) & & - ( 1.0d0 - alp ( nnr - 1 )) * dble ( kk ) * sinen ( kk , jj ) & & * r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj ) !-- Phi(s)*delta(s,nnr) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + kk + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( kk , jj )) & & * ( sines ( nnr - 1 , jj )) & & + ( alp ( nnr - 1 ) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + nrot - 1 + kk + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( kk , jj )) & & * ( sines ( nnr - 1 , jj )) & & - ( alp ( nnr - 1 ) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) end do end do !$omp end do end if end if !$omp barrier if ( ndiv > 0 ) then !-- Set coefficients for D_s and D_c at each (ii,jj) !$omp do schedule(runtime) private(kk,pp,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do pp = 1 , nnrdiv do kk = 1 , ndiv fkij ( ncyc * ( nnr - 1 ) + 2 + 2 + kk + ndiv * ( pp - 1 ), ii , jj ) & & =- ( r_inv ( ii ) * dble ( kk ) * 0.5d0 * ( rddiv ( 2 * pp ) - rddiv ( 2 * pp - 1 )) & ! For Dc & * ( rddiv ( 2 * pp ) * gkrr ( kk , 2 * pp , ii ) + rddiv ( 2 * pp - 1 ) * gkrr ( kk , 2 * pp - 1 , ii )) & & * sinen ( kk , jj ) * sines ( ii , jj ) & & + 0.5d0 * ( rddiv ( 2 * pp ) - rddiv ( 2 * pp - 1 )) * dr_inv ( ii ) & & * ( rddiv ( 2 * pp ) * ( gkrr ( kk , 2 * pp , ii + 1 ) - gkrr ( kk , 2 * pp , ii )) & & + rddiv ( 2 * pp - 1 ) * ( gkrr ( kk , 2 * pp - 1 , ii + 1 ) - gkrr ( kk , 2 * pp - 1 , ii ))) & & * cosinen ( kk , jj ) * cosines ( ii , jj )) end do end do end do end do !$omp end do !$omp barrier end if !$omp end parallel if ( nmax > 0 ) then deallocate ( sinen ) deallocate ( cosinen ) deallocate ( gkrr ) end if call stdout ( \"Finish procedure.\" , \"calc_fkij\" , 0 ) end subroutine calc_fkij !-------------------------------------------------- !-- calculate a_kp from f_kij !-------------------------------------------------- subroutine calc_fkij2akp ( fkij , akp , undeflag ) implicit none double precision , intent ( in ) :: fkij (:,:,:) double precision , intent ( out ) :: akp ( size ( fkij , 1 ), size ( fkij , 1 )) logical , intent ( in ) :: undeflag ( size ( fkij , 2 ), size ( fkij , 3 )) integer :: nnk , nni , nnj , ii , jj , kk , ll , cstat double precision , allocatable , dimension (:,:,:) :: fkl , fpl !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"calc_fkij2akp\" , 0 ) nnk = size ( fkij , 1 ) nni = size ( fkij , 2 ) nnj = size ( fkij , 3 ) ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( fkl ( nni , nnj , ompnum ), stat = cstat ) allocate ( fpl ( nni , nnj , ompnum ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkij2akp\" , - 1 ) stop end if do ll = 1 , nnk !$omp parallel default(shared) !$omp do schedule(dynamic) private(kk,omppe) do kk = ll , nnk !$      omppe=OMP_GET_THREAD_NUM()+1 fkl ( 1 : nni , 1 : nnj , omppe ) = fkij ( kk , 1 : nni , 1 : nnj ) fpl ( 1 : nni , 1 : nnj , omppe ) = fkij ( ll , 1 : nni , 1 : nnj ) akp ( kk , ll ) = matrix_sum ( fkl ( 1 : nni , 1 : nnj , omppe ), fpl ( 1 : nni , 1 : nnj , omppe ), & & undeflag ( 1 : nni , 1 : nnj ) ) akp ( ll , kk ) = akp ( kk , ll ) end do !$omp end do !$omp end parallel end do deallocate ( fkl ) deallocate ( fpl ) call stdout ( \"Finish procedure.\" , \"calc_fkij2akp\" , 0 ) end subroutine calc_fkij2akp !-------------------------------------------------- !-- calculate b_k from f_kij and Vd !-------------------------------------------------- subroutine calc_fkijVd2bk ( vmax , fkij , Vdl , deltaij , bk , undeflag ) implicit none double precision , intent ( in ) :: vmax double precision , intent ( in ) :: fkij (:,:,:) double precision , intent ( in ) :: Vdl ( size ( fkij , 2 ), size ( fkij , 3 )) double precision , intent ( in ) :: deltaij ( size ( fkij , 2 ), size ( fkij , 3 )) double precision , intent ( out ) :: bk ( size ( fkij , 1 )) logical , intent ( in ) :: undeflag ( size ( fkij , 2 ), size ( fkij , 3 )) integer :: nnk , nni , nnj , ii , jj , kk , ll , cstat double precision , allocatable , dimension (:,:,:) :: fkl double precision :: dVdl ( size ( fkij , 2 ), size ( fkij , 3 )) !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"calc_fkijVd2bk\" , 0 ) nnk = size ( fkij , 1 ) nni = size ( fkij , 2 ) nnj = size ( fkij , 3 ) ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( fkl ( nni , nnj , ompnum ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkijVd2bk\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then dVdl ( ii , jj ) = Vdl ( ii , jj ) else dVdl ( ii , jj ) = deltaij ( ii , jj ) * Vdl ( ii , jj ) end if end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,omppe) do kk = 1 , nnk !$   omppe=OMP_GET_THREAD_NUM()+1 fkl ( 1 : nni , 1 : nnj , omppe ) = fkij ( kk , 1 : nni , 1 : nnj ) bk ( kk ) = matrix_sum ( dVdl ( 1 : nni , 1 : nnj ), fkl ( 1 : nni , 1 : nnj , omppe ), & & undeflag ( 1 : nni , 1 : nnj ) ) / vmax end do !$omp end do !$omp end parallel deallocate ( fkl ) call stdout ( \"Finish procedure.\" , \"calc_fkijVd2bk\" , 0 ) end subroutine calc_fkijVd2bk !-------------------------------------------------- !-- Set each unknown variable from x_k !-------------------------------------------------- subroutine set_xk2variables ( nrot , ndiv , nnrdiv , Usrn , Vsrn , vmax , & & xk , VRT0 , VDR0 , & & phis_n , phic_n , Ds_m , undef ) implicit none integer , intent ( in ) :: nrot integer , intent ( in ) :: ndiv integer , intent ( in ) :: nnrdiv double precision , intent ( in ) :: Usrn ( 2 ) double precision , intent ( in ) :: Vsrn ( 2 ) double precision , intent ( in ) :: vmax double precision , intent ( in ) :: xk (:) ! solved unknown variable vector double precision , intent ( out ) :: VRT0 (:) double precision , intent ( out ) :: VDR0 ( size ( VRT0 )) double precision , intent ( out ), optional :: phis_n ( nrot , size ( VRT0 ) + 1 ) double precision , intent ( out ), optional :: phic_n ( nrot , size ( VRT0 ) + 1 ) double precision , intent ( out ), optional :: Ds_m ( ndiv , nnrdiv ) double precision , intent ( in ), optional :: undef integer :: ii , kk , nnk , nnr , ncyc double precision :: Usrn_n ( 2 ), Vsrn_n ( 2 ) call stdout ( \"Enter procedure.\" , \"set_xk2variables\" , 0 ) nnk = size ( xk ) nnr = size ( VRT0 ) ncyc = 2 + 2 * nrot Usrn_n ( 1 : 2 ) = Usrn ( 1 : 2 ) / vmax Vsrn_n ( 1 : 2 ) = Vsrn ( 1 : 2 ) / vmax !-- Set VRT0 and VDR0 do ii = 1 , nnr - 1 VRT0 ( ii ) = xk ( 1 + ncyc * ( ii - 1 )) VDR0 ( ii ) = xk ( 2 + ncyc * ( ii - 1 )) end do VRT0 ( nnr ) = xk ( 1 + ncyc * ( nnr - 1 )) VDR0 ( nnr ) = xk ( 2 + ncyc * ( nnr - 1 )) !-- Set Phi_s and Phi_c if ( nrot > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr - 1 do kk = 1 , nrot phis_n ( kk , ii ) = xk ( 2 + kk + ncyc * ( ii - 1 )) phic_n ( kk , ii ) = xk ( 2 + nrot + kk + ncyc * ( ii - 1 )) end do end do !$omp end do !$omp end parallel phis_n ( 1 , nnr ) = xk ( 2 + 1 + ncyc * ( nnr - 1 )) phis_n ( 1 , nnr + 1 ) = xk ( 2 + 2 + ncyc * ( nnr - 1 )) end if !-- Set D_s and D_c if ( ndiv > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnrdiv do kk = 1 , ndiv Ds_m ( kk , ii ) = xk ( ncyc * ( nnr - 1 ) + 2 + 2 + kk + ndiv * ( ii - 1 )) end do end do !$omp end do !$omp end parallel end if call stdout ( \"Finish procedure.\" , \"set_xk2variables\" , 0 ) end subroutine set_xk2variables !-------------------------------------------------- !-- Calculate Vr and Vt components of rotating wind !-------------------------------------------------- subroutine calc_phi2Vrot ( nrot , Usrn , Vsrn , vmax , rd , rdh , theta , VRT0_r , & & VRT0_rt , VRT_nrt , VRR_nrt , & & phis_nr , phic_nr , undef ) implicit none integer , intent ( in ) :: nrot double precision , intent ( in ) :: Usrn ( 2 ) double precision , intent ( in ) :: Vsrn ( 2 ) double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) double precision , intent ( in ) :: theta (:) double precision , intent ( in ) :: VRT0_r ( size ( rd )) double precision , intent ( out ) :: VRT0_rt ( size ( rd ), size ( theta )) double precision , intent ( out ), optional :: VRT_nrt ( nrot , size ( rd ), size ( theta )) double precision , intent ( out ), optional :: VRR_nrt ( nrot , size ( rd ), size ( theta )) double precision , intent ( inout ), optional :: phis_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( inout ), optional :: phic_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( in ), optional :: undef ! No use integer :: ii , jj , kk , nnr , nnt , cstat double precision :: Usrn_n ( 2 ), Vsrn_n ( 2 ) double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp double precision , allocatable , dimension (:,:) :: cosinen , sinen call stdout ( \"Enter procedure.\" , \"calc_phi2Vrot\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) if ( nrot > 0 ) then allocate ( cosinen ( nrot , nnt ), stat = cstat ) allocate ( sinen ( nrot , nnt ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_phi2Vrot\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , nrot cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp end parallel end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) Usrn_n ( 1 : 2 ) = Usrn ( 1 : 2 ) / vmax Vsrn_n ( 1 : 2 ) = Vsrn ( 1 : 2 ) / vmax do ii = 1 , nnr VRT0_rt ( ii , 1 : nnt ) = VRT0_r ( ii ) * vmax end do if ( nrot > 0 ) then VRT_nrt = 0.0d0 VRR_nrt = 0.0d0 !-- set the outermost boundary for wavenumber 1 phic_nr ( 1 , nnr + 1 ) =- rdh ( nnr + 1 ) * ( Vsrn_n ( 2 ) - Vsrn_n ( 1 )) phic_nr ( 1 , nnr ) =- rdh ( nnr ) * ( Vsrn_n ( 2 ) - Vsrn_n ( 1 )) !-- set the outermost boundary for wavenumber 2 if ( nrot > 1 ) then do kk = 2 , nrot phis_nr ( kk , nnr + 1 ) = 0.0d0 phic_nr ( kk , nnr + 1 ) = 0.0d0 phis_nr ( kk , nnr ) = 0.0d0 phic_nr ( kk , nnr ) = 0.0d0 end do end if !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot VRT_nrt ( kk , ii , jj ) =- dr_inv ( ii ) * (( phis_nr ( kk , ii + 1 ) - phis_nr ( kk , ii )) * sinen ( kk , jj ) & & + ( phic_nr ( kk , ii + 1 ) - phic_nr ( kk , ii )) * cosinen ( kk , jj )) VRR_nrt ( kk , ii , jj ) = dble ( kk ) * r_inv ( ii ) & & * (( alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii )) * cosinen ( kk , jj ) & & - ( alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii )) * sinen ( kk , jj )) VRT_nrt ( kk , ii , jj ) = VRT_nrt ( kk , ii , jj ) * vmax VRR_nrt ( kk , ii , jj ) = VRR_nrt ( kk , ii , jj ) * vmax end do end do end do !$omp end do !$omp end parallel end if if ( nrot > 0 ) then deallocate ( cosinen ) deallocate ( sinen ) end if call stdout ( \"Finish procedure.\" , \"calc_phi2Vrot\" , 0 ) end subroutine calc_phi2Vrot !-------------------------------------------------- !-- Calculate Vr and Vt components of divergent wind !-------------------------------------------------- subroutine calc_D2Vdiv ( ndiv , vmax , rd , rdh , theta , rddiv , VDR0_r , & & VDR0_rt , VDT_mrt , VDR_mrt , Ds_mr , undef ) implicit none integer , intent ( in ) :: ndiv double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rd (:) double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) double precision , intent ( in ) :: theta (:) double precision , intent ( in ) :: rddiv (:) double precision , intent ( in ) :: VDR0_r ( size ( rd )) double precision , intent ( out ) :: VDR0_rt ( size ( rd ), size ( theta )) double precision , intent ( out ), optional :: VDT_mrt ( ndiv , size ( rd ), size ( theta )) double precision , intent ( out ), optional :: VDR_mrt ( ndiv , size ( rd ), size ( theta )) double precision , intent ( in ), optional :: Ds_mr ( ndiv , size ( rddiv )) double precision , intent ( in ), optional :: undef integer :: ii , jj , kk , nnr , nnt , nnrdiv , nnrdiv2 , cstat , irad !  double precision :: rmax_inv double precision , dimension ( size ( rd )) :: dr_inv , dr , r_inv double precision , allocatable , dimension (:,:) :: cosinen , sinen double precision , allocatable , dimension (:,:,:) :: gkrr , gkrrh , dgkrr double precision :: tmp_Ds_mr ( ndiv , size ( rd ) + 1 ) call stdout ( \"Enter procedure.\" , \"calc_D2Vdiv\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) nnrdiv2 = size ( rddiv ) nnrdiv = nnrdiv2 / 2 if ( ndiv > 0 ) then allocate ( cosinen ( ndiv , nnt ), stat = cstat ) allocate ( sinen ( ndiv , nnt ), stat = cstat ) allocate ( gkrr ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rdh allocate ( gkrrh ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rdh allocate ( dgkrr ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r+1)-Gk(r_p,r), r_p at rdh, r at rdh if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_D2Vdiv\" , - 1 ) stop end if cosinen = 0.0d0 sinen = 0.0d0 gkrr = 0.0d0 gkrrh = 0.0d0 dgkrr = 0.0d0 tmp_Ds_mr = 0.0d0 do kk = 1 , ndiv do ii = 1 , nnrdiv call interpo_search_1d ( rdh , rddiv ( 2 * ii - 1 ), irad ) tmp_Ds_mr ( kk , irad ) = Ds_mr ( kk , ii ) call interpo_search_1d ( rdh , rddiv ( 2 * ii ), irad ) tmp_Ds_mr ( kk , irad ) = Ds_mr ( kk , ii ) end do end do end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) do ii = 1 , nnr VDR0_rt ( ii , 1 : nnt ) = VDR0_r ( ii ) * vmax end do if ( ndiv > 0 ) then VDT_mrt = 0.0d0 VDR_mrt = 0.0d0 !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , ndiv cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrr ( kk , ii , jj ) = green_func ( rdh ( ii ), rd ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) ! At the outer boundary for r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrr ( kk , ii , nnr + 1 ) = green_func ( rdh ( ii ), rdh ( nnr + 1 ), kk ) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr + 1 ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrrh ( kk , ii , jj ) = green_func ( rdh ( ii ), rdh ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv dgkrr ( kk , ii , jj ) = gkrr ( kk , ii , jj + 1 ) - gkrr ( kk , ii , jj ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , ndiv VDT_mrt ( kk , ii , jj ) =- ( dr ( ii ) * dble ( kk ) * r_inv ( ii ) * vmax ) & & * ( - line_integral ( nnr , rdh ( 1 : nnr + 1 ), gkrr ( kk , 1 : nnr + 1 , ii ), tmp_Ds_mr ( kk , 1 : nnr + 1 ) ) & & * sinen ( kk , jj )) VDR_mrt ( kk , ii , jj ) =- ( vmax ) & & * ( + line_integral ( nnr , rdh ( 1 : nnr + 1 ), dgkrr ( kk , 1 : nnr + 1 , ii ), tmp_Ds_mr ( kk , 1 : nnr + 1 ) ) & & * cosinen ( kk , jj )) end do end do end do !$omp end do !$omp end parallel end if if ( ndiv > 0 ) then deallocate ( cosinen ) deallocate ( sinen ) deallocate ( gkrr ) deallocate ( gkrrh ) deallocate ( dgkrr ) end if call stdout ( \"Finish procedure.\" , \"calc_D2Vdiv\" , 0 ) end subroutine calc_D2Vdiv !-------------------------------------------------- !-- Calculate total wind from all wavenumbers !-------------------------------------------------- subroutine calc_Vn2Vtot ( nrot , ndiv , V0 , Vn , Vm , Vtot , undef ) implicit none integer , intent ( in ) :: nrot integer , intent ( in ) :: ndiv double precision , intent ( in ) :: V0 (:,:) double precision , intent ( in ) :: Vn ( nrot , size ( V0 , 1 ), size ( V0 , 2 )) double precision , intent ( in ) :: Vm ( ndiv , size ( V0 , 1 ), size ( V0 , 2 )) double precision , intent ( inout ) :: Vtot ( size ( V0 , 1 ), size ( V0 , 2 )) double precision , intent ( in ), optional :: undef integer :: ii , jj , kk , nnr , nnt call stdout ( \"Enter procedure.\" , \"calc_Vn2Vtot\" , 0 ) nnr = size ( V0 , 1 ) nnt = size ( V0 , 2 ) Vtot = V0 if ( present ( undef )) then do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot if ( Vn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vn ( kk , ii , jj ) end if end do do kk = 1 , ndiv if ( Vn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vm ( kk , ii , jj ) end if end do end do end do else do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vn ( kk , ii , jj ) end do do kk = 1 , ndiv Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vm ( kk , ii , jj ) end do end do end do end if call stdout ( \"Finish procedure.\" , \"calc_Vn2Vtot\" , 0 ) end subroutine calc_Vn2Vtot !-------------------------------------------------- !-- calculate inner product of two vectors !-------------------------------------------------- double precision function dot_prod ( v1 , v2 ) implicit none double precision , intent ( in ) :: v1 (:) double precision , intent ( in ) :: v2 ( size ( v1 )) integer :: ii , ni double precision :: res ni = size ( v1 ) res = 0.0d0 do ii = 1 , ni res = res + v1 ( ii ) * v2 ( ii ) end do dot_prod = res return end function dot_prod !-------------------------------------------------- !-- calculate product for a component in a matrix !-------------------------------------------------- double precision function matrix_sum ( aij , akj , undeflag ) implicit none double precision , intent ( in ) :: aij (:,:) double precision , intent ( in ) :: akj ( size ( aij , 1 ), size ( aij , 2 )) logical , intent ( in ), optional :: undeflag ( size ( aij , 1 ), size ( aij , 2 )) integer :: ii , jj , ni , nj double precision :: res ni = size ( aij , 1 ) nj = size ( aij , 2 ) res = 0.0d0 if ( present ( undeflag )) then do jj = 1 , nj do ii = 1 , ni if ( undeflag ( ii , jj ). eqv .. false .) then res = res + aij ( ii , jj ) * akj ( ii , jj ) end if end do end do else do jj = 1 , nj do ii = 1 , ni res = res + aij ( ii , jj ) * akj ( ii , jj ) end do end do end if matrix_sum = res return end function matrix_sum !-------------------------------------------------- !-------------------------------------------------- subroutine check_zero ( a ) implicit none double precision , intent ( in ) :: a (:,:) integer :: ii , jj , nni , nnj logical :: res nni = size ( a , 1 ) nnj = size ( a , 2 ) do jj = 1 , nnj res = . false . do ii = 1 , nni if ( a ( ii , jj ) /= 0.0d0 ) then res = . true . exit end if end do if ( res . eqv .. false .) then write ( * , * ) \"Detect all zero\" , jj end if end do end subroutine check_zero !-------------------------------------------------- !-------------------------------------------------- subroutine check_undef_grid ( vval , undefv , undeflag ) implicit none double precision , intent ( in ) :: vval (:,:) double precision , intent ( in ) :: undefv logical , intent ( out ) :: undeflag ( size ( vval , 1 ), size ( vval , 2 )) integer :: ii , jj , nni , nnj nni = size ( vval , 1 ) nnj = size ( vval , 2 ) undeflag = . false . do jj = 1 , nnj do ii = 1 , nni if ( vval ( ii , jj ) == undefv ) then undeflag ( ii , jj ) = . true . end if end do end do end subroutine check_undef_grid !-------------------------------------------------- !-------------------------------------------------- subroutine set_undef_value ( undeflag , undefv , vval ) implicit none logical , intent ( in ) :: undeflag (:,:) double precision , intent ( in ) :: undefv double precision , intent ( inout ) :: vval ( size ( undeflag , 1 ), size ( undeflag , 2 )) integer :: ii , jj , nni , nnj nni = size ( undeflag , 1 ) nnj = size ( undeflag , 2 ) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then vval ( ii , jj ) = undefv end if end do end do end subroutine set_undef_value !-------------------------------------------------- ! Calculate streamfunction for each wavenumber !-------------------------------------------------- subroutine calc_Phi2Phin ( nrot , vmax , rmax , rd , rdh , theta , phis_nr , phic_nr , phi_nr ) implicit none integer , intent ( in ) :: nrot double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rmax double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) double precision , intent ( in ) :: theta (:) double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( out ) :: phi_nr ( nrot , size ( rd ), size ( theta )) integer :: ii , jj , kk , nnr , nnt , cstat double precision , dimension ( size ( rd )) :: alp double precision , dimension ( nrot , size ( theta )) :: sinen , cosinen double precision :: phisi , phici call stdout ( \"Enter procedure.\" , \"calc_Phi2Phin\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do jj = 1 , nnt do kk = 1 , nrot sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp end parallel do ii = 1 , nnr alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii,jj,phisi,phici) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot phisi = alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii ) phici = alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii ) phi_nr ( kk , ii , jj ) = ( phisi * sinen ( kk , jj ) + phici * cosinen ( kk , jj )) * vmax * rmax end do end do end do !$omp end do !$omp end parallel call stdout ( \"Finish procedure.\" , \"calc_Phi2Phin\" , 0 ) end subroutine calc_Phi2Phin !-------------------------------------------------- ! Calculate vorticity for each wavenumber !-------------------------------------------------- subroutine calc_Phi2Zetan ( nrot , vmax , rmax , rd , rdh , theta , phis_nr , phic_nr , zeta_nr ) implicit none integer , intent ( in ) :: nrot double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rmax double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) double precision , intent ( in ) :: theta (:) double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( out ) :: zeta_nr ( nrot , size ( rd ), size ( theta )) integer :: ii , jj , kk , nnr , nnt , cstat double precision , dimension ( size ( rd )) :: alp double precision , dimension ( nrot , size ( rd ) + 1 ) :: d2psdr2 , d2pcdr2 , dpsdr , dpcdr , psinv , pcinv double precision , dimension ( nrot , size ( theta )) :: sinen , cosinen double precision , dimension ( nrot , 0 : size ( rd ) + 2 ) :: tmpphis , tmpphic double precision , dimension ( size ( rd ) + 1 ) :: drc_inv , drf_inv , drb_inv , rh_inv , rh2_inv double precision , dimension ( size ( rd )) :: r_inv double precision :: dpfs , dpfc , dpbs , dpbc , rmax_inv double precision :: d2psdr2i , dpsdri , d2pcdr2i , dpcdri , phisi , phici call stdout ( \"Enter procedure.\" , \"calc_Phi2Zetan\" , 0 ) if ( nrot < 1 ) then call stdout ( \"nrot is greater than 0. stop.\" , \"calc_Phi2Zetan\" , - 1 ) stop end if nnr = size ( rd ) nnt = size ( theta ) drc_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drc_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) drb_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drb_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) drf_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drf_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) rh_inv ( nnr + 1 ) = 1.0 / rdh ( nnr + 1 ) if ( rdh ( 1 ) == 0.0d0 ) then rh_inv ( 1 ) = 0.0d0 end if if ( rd ( 1 ) == 0.0d0 ) then r_inv ( 1 ) = 0.0d0 end if do ii = 2 , nnr drc_inv ( ii ) = 1.0d0 / ( rdh ( ii + 1 ) - rdh ( ii - 1 )) drb_inv ( ii ) = 1.0d0 / ( rdh ( ii ) - rdh ( ii - 1 )) drf_inv ( ii ) = 1.0d0 / ( rdh ( ii + 1 ) - rdh ( ii )) rh_inv ( ii ) = 1.0d0 / rdh ( ii ) r_inv ( ii ) = 1.0d0 / rd ( ii ) end do rmax_inv = 1.0d0 / rmax rh2_inv = rh_inv ** 2 tmpphis ( 1 : nrot , 1 : nnr + 1 ) = phis_nr ( 1 : nrot , 1 : nnr + 1 ) tmpphic ( 1 : nrot , 1 : nnr + 1 ) = phic_nr ( 1 : nrot , 1 : nnr + 1 ) tmpphis ( 1 : nrot , 0 ) = phis_nr ( 1 : nrot , 1 ) ! dummy tmpphis ( 1 : nrot , nnr + 2 ) = phis_nr ( 1 : nrot , nnr + 1 ) ! dummy tmpphic ( 1 : nrot , 0 ) = phic_nr ( 1 : nrot , 1 ) ! dummy tmpphic ( 1 : nrot , nnr + 2 ) = phic_nr ( 1 : nrot , nnr + 1 ) ! dummy zeta_nr = 0.0d0 do ii = 1 , nnr alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do jj = 1 , nnt do kk = 1 , nrot sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr + 1 do kk = 1 , nrot d2psdr2 ( kk , ii ) = 2.0d0 * drc_inv ( ii ) & & * (( tmpphis ( kk , ii + 1 ) - tmpphis ( kk , ii )) * drf_inv ( ii ) & & + ( tmpphis ( kk , ii - 1 ) - tmpphis ( kk , ii )) * drb_inv ( ii )) d2pcdr2 ( kk , ii ) = 2.0d0 * drc_inv ( ii ) & & * (( tmpphic ( kk , ii + 1 ) - tmpphic ( kk , ii )) * drf_inv ( ii ) & & + ( tmpphic ( kk , ii - 1 ) - tmpphic ( kk , ii )) * drb_inv ( ii )) dpsdr ( kk , ii ) = 0.5d0 * (( tmpphis ( kk , ii + 1 ) - tmpphis ( kk , ii )) * drf_inv ( ii ) & & - ( tmpphis ( kk , ii - 1 ) - tmpphis ( kk , ii )) * drb_inv ( ii )) dpcdr ( kk , ii ) = 0.5d0 * (( tmpphic ( kk , ii + 1 ) - tmpphic ( kk , ii )) * drf_inv ( ii ) & & - ( tmpphic ( kk , ii - 1 ) - tmpphic ( kk , ii )) * drb_inv ( ii )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj,d2psdr2i,dpsdri,d2pcdr2i,dpcdri,phisi,phici) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot phisi = alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii ) phici = alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii ) d2psdr2i = alp ( ii ) * d2psdr2 ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * d2psdr2 ( kk , ii ) dpsdri = alp ( ii ) * dpsdr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * dpsdr ( kk , ii ) d2pcdr2i = alp ( ii ) * d2pcdr2 ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * d2pcdr2 ( kk , ii ) dpcdri = alp ( ii ) * dpcdr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * dpcdr ( kk , ii ) zeta_nr ( kk , ii , jj ) = (( d2psdr2i + dpsdri * r_inv ( ii ) & & - (( dble ( kk ) * r_inv ( ii )) ** 2 ) * phisi ) & & * sinen ( kk , jj ) & & + ( d2pcdr2i + dpcdri * r_inv ( ii ) & & - (( dble ( kk ) * r_inv ( ii )) ** 2 ) * phici ) & & * cosinen ( kk , jj )) & & * vmax * rmax_inv end do end do end do !$omp end do !$omp end parallel call stdout ( \"Finish procedure.\" , \"calc_Phi2Zetan\" , 0 ) end subroutine calc_Phi2Zetan !-------------------------------------------------- ! Calculate pseudo retrieval of VT and VR for GVTD !-------------------------------------------------- subroutine calc_pseudo_GVTD0 ( nrot , vmax , rtc , rd , rdh , VRT0_r , VDR0_r , & & phis_nr , phic_nr , VRT0_GVTD_r , VDR0_GVTD_r ) implicit none integer , intent ( in ) :: nrot double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rtc ! Normalized radius double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) ! Normalized radius double precision , intent ( in ) :: VRT0_r ( size ( rd )) double precision , intent ( in ) :: VDR0_r ( size ( rd )) double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( out ) :: VRT0_GVTD_r ( size ( rd )) double precision , intent ( out ) :: VDR0_GVTD_r ( size ( rd )) integer :: ii , jj , kk , nnr , cstat double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp double precision , dimension ( size ( rd )) :: tmp_VRT0_r , tmp_VDR0_r call stdout ( \"Enter procedure.\" , \"calc_pseudo_GVTD0\" , 0 ) nnr = size ( rd ) do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) tmp_VRT0_r ( 1 : nnr ) = VRT0_r ( 1 : nnr ) tmp_VDR0_r ( 1 : nnr ) = VDR0_r ( 1 : nnr ) if ( nrot > 0 ) then !$omp parallel default(shared) !-- For wavenumber 1 !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + (( alp ( ii ) * phic_nr ( 1 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 1 , ii )) / rtc ) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 1 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 1 , ii )) * vmax end do !$omp end do !$omp barrier !-- For wavenumber 2 if ( nrot > 1 ) then !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + 2.0d0 * r_inv ( ii ) * ( alp ( ii ) * phic_nr ( 2 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 2 , ii )) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + 2.0d0 * r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 2 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 2 , ii )) * vmax end do !$omp end do end if !$omp barrier !-- For wavenumber 3 if ( nrot > 2 ) then !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + 3.0d0 * (( alp ( ii ) * phic_nr ( 3 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 3 , ii )) / rtc ) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + 3.0d0 * r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 3 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 3 , ii )) * vmax end do !$omp end do end if !$omp end parallel VRT0_GVTD_r ( 1 : nnr ) = tmp_VRT0_r ( 1 : nnr ) VDR0_GVTD_r ( 1 : nnr ) = tmp_VDR0_r ( 1 : nnr ) end if call stdout ( \"Finish procedure.\" , \"calc_pseudo_GVTD0\" , 0 ) end subroutine calc_pseudo_GVTD0 !-------------------------------------------------- ! Calculate sine and cosine components of Vt and VR for rot !-------------------------------------------------- subroutine calc_phi2sc ( nrot , vmax , rd , rdh , phis_nr , phic_nr , & & VRTns_r , VRTnc_r , VRRns_r , VRRnc_r ) implicit none integer , intent ( in ) :: nrot double precision , intent ( in ) :: vmax double precision , intent ( in ) :: rd (:) ! Normalized radius double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) ! Normalized radius double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) double precision , intent ( out ) :: VRTns_r ( nrot , size ( rd )) double precision , intent ( out ) :: VRTnc_r ( nrot , size ( rd )) double precision , intent ( out ) :: VRRns_r ( nrot , size ( rd )) double precision , intent ( out ) :: VRRnc_r ( nrot , size ( rd )) integer :: ii , jj , kk , nnr , cstat double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp call stdout ( \"Enter procedure.\" , \"calc_phi2sc\" , 0 ) nnr = size ( rd ) do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) if ( nrot > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr do kk = 1 , nrot VRTns_r ( kk , ii ) =- ( phis_nr ( kk , ii + 1 ) - phis_nr ( kk , ii )) * dr_inv ( ii ) * vmax VRTnc_r ( kk , ii ) =- ( phic_nr ( kk , ii + 1 ) - phic_nr ( kk , ii )) * dr_inv ( ii ) * vmax VRRns_r ( kk , ii ) =- dble ( kk ) * ( alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii )) * r_inv ( ii ) * vmax VRRnc_r ( kk , ii ) = dble ( kk ) * ( alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii )) * r_inv ( ii ) * vmax end do end do !$omp end do !$omp end parallel end if call stdout ( \"Finish procedure.\" , \"calc_phi2sc\" , 0 ) end subroutine calc_phi2sc end module GVTDX_main2","tags":"","loc":"sourcefile/gvtdx_main_mod2.f90.html"},{"title":"gvtdx_main_mod.f90 – GVTD-HeCs","text":"This file depends on sourcefile~~gvtdx_main_mod.f90~~EfferentGraph sourcefile~gvtdx_main_mod.f90 gvtdx_main_mod.f90 sourcefile~sub_mod.f90 sub_mod.f90 sourcefile~gvtdx_main_mod.f90->sourcefile~sub_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GVTDX_main Source Code gvtdx_main_mod.f90 Source Code module GVTDX_main !! The main module of GVTD-X use GVTDX_sub implicit none public :: Retrieve_velocity_GVTDX private :: calc_fkij private :: calc_fkij2akp private :: calc_fkijVd2bk private :: set_xk2variables private :: calc_phi2Vrot private :: calc_D2Vdiv private :: calc_Vn2Vtot private :: check_zero private :: check_undef_grid private :: set_undef_value private :: calc_Phi2Phin private :: calc_Phi2Zetan private :: calc_pseudo_GVTD0 private :: calc_phi2sc contains subroutine Retrieve_velocity_GVTDX ( nrot , ndiv , r , t , rh , td , rdiv , Vd , Un , Vn , RadTC , & & VT , VR , VRT0 , VDR0 , VRTn , VRRn , VDTm , VDRm , & & undef , phin , zetan , VRT0_GVTD , VDR0_GVTD , & & VRTns , VRTnc , VRRns , VRRnc ) !! Solve unknown variables and return wind velocity on R-T coordinates. <br> !!------------------------------------------------------- <br> !!-- [relationship between r and rh] -- <br> !!------------------------------------------------------- <br> !!--   i-1    i    i+1 <br> !!-- ...|-- --|-- --|... : r(1:size(r)) = velocity radii <br> !!-- |-- --|-- --|-- --| : rh(1,size(r)+1) = potential radii <br> !!--i-1    i    i+1   i+2 <br> !!------------------------------------------------------- implicit none !-- input/output integer , intent ( in ) :: nrot !! wave number for rotating wind integer , intent ( in ) :: ndiv !! wave number for divergent wind double precision , intent ( in ) :: r (:) !! radial coordinate on which Vd is defined [m] double precision , intent ( in ) :: t (:) !! azimuthal coordinate on which Vd is defined [rad] double precision , intent ( in ) :: rh ( size ( r ) + 1 ) !! radial coordinate on which Phi (staggered for Vd) is defined [m] double precision , intent ( in ) :: td ( size ( r ), size ( t )) !! radar azimuthal angle defined at Vd(r,t) [rad] double precision , intent ( in ) :: rdiv (:) !! radial coordinate on which Dc (staggered for Vd) is defined [m] double precision , intent ( inout ) :: Vd ( size ( r ), size ( t )) !! Doppler velocity defined on r-t [m s-1] double precision , intent ( in ) :: Un ( 2 ) !! Parallel component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: Vn ( 2 ) !! Normal component to radar in environmental wind, defined on r-t [m s-1] double precision , intent ( in ) :: RadTC !! Distance from radar to TC center [m] double precision , intent ( out ) :: VT ( size ( r ), size ( t )) !! retrieved total tangential wind [m s-1] double precision , intent ( out ) :: VR ( size ( r ), size ( t )) !! retrieved total radial wind [m s-1] double precision , intent ( out ) :: VRT0 ( size ( r ), size ( t )) !! retrieved axisymmetric radial component of rotating wind [m s-1] double precision , intent ( out ) :: VDR0 ( size ( r ), size ( t )) !! retrieved axisymmetric tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VRTn ( nrot , size ( r ), size ( t )) !! retrieved tangential component of rotating wind [m s-1] double precision , intent ( out ) :: VRRn ( nrot , size ( r ), size ( t )) !! retrieved radial component of rotating wind [m s-1] double precision , intent ( out ) :: VDTm ( ndiv , size ( r ), size ( t )) !! retrieved tangential component of divergent wind [m s-1] double precision , intent ( out ) :: VDRm ( ndiv , size ( r ), size ( t )) !! retrieved radial component of divergent wind [m s-1] double precision , intent ( in ), optional :: undef !! undefined value for Vd double precision , intent ( out ), optional :: phin ( nrot , size ( r ), size ( t )) !! retrieved stream function [m2 s-1] double precision , intent ( out ), optional :: zetan ( nrot , size ( r ), size ( t )) !! retrieved vorticity [s-1] double precision , intent ( out ), optional :: VRT0_GVTD ( size ( r ), size ( t )) !! retrieved axisymmetric radial component of pseudo-GVTD tangential wind [m s-1] double precision , intent ( out ), optional :: VDR0_GVTD ( size ( r ), size ( t )) !! retrieved axisymmetric tangential component of pseudo-GVTD tangential wind [m s-1] double precision , intent ( out ), optional :: VRTns ( nrot , size ( r ), size ( t )) !! Sine component of retrieved asymmetric radial wind [m s-1] double precision , intent ( out ), optional :: VRTnc ( nrot , size ( r ), size ( t )) !! Cosine component of retrieved asymmetric radial wind [m s-1] double precision , intent ( out ), optional :: VRRns ( nrot , size ( r ), size ( t )) !! Sine component of retrieved asymmetric tangential wind [m s-1] double precision , intent ( out ), optional :: VRRnc ( nrot , size ( r ), size ( t )) !! Cosine component of retrieved asymmetric tangential wind [m s-1] !-- internal variables integer :: i , j , k , p , irad , cstat ! dummy indexes integer :: nr , nt ! array numbers for r and t, respectively integer :: nk ! array number of a_k integer :: nrdiv ! array number for rdiv integer :: nrdiv2 ! array number for rdiv_n integer :: nbound ! element number for variables related to the outermost radius (i.e., 2*nrot-1) double precision , allocatable , dimension (:) :: Vdivr_r ! axisymmetric divergent wind (VDR0(r)) double precision , allocatable , dimension (:) :: Vrott_r ! axisymmetric rotating wind (VRT0(r)) double precision , allocatable , dimension (:,:) :: phis_nr ! asymmetric (sine) stream function (Phi_S(n,r)) double precision , allocatable , dimension (:,:) :: phic_nr ! asymmetric (cosine) stream function (Phi_C(n,r)) double precision , allocatable , dimension (:,:) :: divc_mr ! asymmetric (cosine) stream function (D_C(n,r)) double precision , allocatable , dimension (:) :: GVTDU_r ! axisymmetric radial wind for pseudo-GVTD double precision , allocatable , dimension (:) :: GVTDV_r ! axisymmetric tangential wind for pseudo-GVTD double precision , allocatable , dimension (:,:) :: VRTns_r ! sine component of tangential wind double precision , allocatable , dimension (:,:) :: VRTnc_r ! cosine component of tangential wind double precision , allocatable , dimension (:,:) :: VRRns_r ! sine component of radial wind double precision , allocatable , dimension (:,:) :: VRRnc_r ! cosine component of radial wind double precision , allocatable , dimension (:) :: x_k ! unknown vector for retrieved coefficients double precision , allocatable , dimension (:) :: b_k ! known vector given by observed values double precision , allocatable , dimension (:,:) :: a_kp ! coefficient matrix for x_k double precision , allocatable , dimension (:,:,:) :: f_kij ! a_kp = sum_{i,j}(f_kij * f_pij) double precision :: dundef , vmax , tmprho double precision , dimension ( size ( r )) :: r_n ! Nondimensional r double precision , dimension ( size ( rh )) :: rh_n ! Nondimensional rh double precision , dimension ( size ( rdiv ) * 2 ) :: rdiv_n ! Nondimensional rdiv (internal variable) double precision :: rtc_n ! Nondimensional RadTC double precision , dimension ( size ( r ), size ( t )) :: delta ! delta_ij logical , allocatable , dimension (:,:) :: undeflag ! Flag for Vd grid with undef call stdout ( \"Enter procedure.\" , \"Retrieve_velocity_GVTDX\" , 0 ) nr = size ( r ) nt = size ( t ) nrdiv = size ( rdiv ) nrdiv2 = size ( rdiv ) * 2 vmax = 5 0.0d0 if ( present ( undef )) then dundef = undef else dundef =- 1.0d35 end if VT = dundef VR = dundef VRT0 = dundef VDR0 = dundef VRTn = dundef VRRn = dundef VDTm = dundef VDRm = dundef delta = undef if ( present ( phin )) then phin = dundef end if if ( present ( zetan )) then zetan = dundef end if if ( present ( VRT0_GVTD )) then VRT0_GVTD = dundef allocate ( GVTDV_r ( nr ), stat = cstat ) end if if ( present ( VDR0_GVTD )) then VDR0_GVTD = dundef allocate ( GVTDU_r ( nr ), stat = cstat ) end if if ( present ( VRTns )) then VRTns = dundef VRTnc = dundef VRRns = dundef VRRnc = dundef allocate ( VRTns_r ( nrot , nr ), stat = cstat ) allocate ( VRTnc_r ( nrot , nr ), stat = cstat ) allocate ( VRRns_r ( nrot , nr ), stat = cstat ) allocate ( VRRnc_r ( nrot , nr ), stat = cstat ) end if !-- Check retrieved asymmetric wave number if ( nrot < 0 ) then call stdout ( \"nrot is greater equal to 0. stop.\" , \"Retrieve_velocity_GVTDX\" , - 1 ) stop end if if ( ndiv < 0 ) then call stdout ( \"ndiv is greater equal to 0. stop.\" , \"Retrieve_velocity_GVTDX\" , - 1 ) stop end if !-- Normalized r and rh r_n = r / rh ( nr + 1 ) rh_n = rh / rh ( nr + 1 ) rtc_n = RadTC / rh ( nr + 1 ) !-- Check and search divergent radii do i = 1 , nrdiv call interpo_search_1d ( rh , rdiv ( i ), irad ) if (( irad == nr + 1 ). and .( rh ( nr + 1 ) < rdiv ( i ))) then if ( ndiv > 0 ) then call stdout ( \"Detect out of range. stop.\" , \"Retrieve_velocity_GVTDX\" , - 1 ) stop else ! Not use of rdiv call stdout ( \"Detect out of range.\" , \"Retrieve_velocity_GVTDX\" , 1 ) irad = nr end if end if rdiv_n ( 2 * i - 1 ) = rh ( irad ) / rh ( nr + 1 ) rdiv_n ( 2 * i ) = rh ( irad + 1 ) / rh ( nr + 1 ) end do !-- Calculate delta_ij !$omp parallel default(shared) !$omp do schedule(runtime) private(i,j,tmprho) do j = 1 , nt do i = 1 , nr if ( r_n ( i ) > 0.0d0 ) then tmprho = rtc_n / r_n ( i ) delta ( i , j ) = dsqrt ( tmprho ** 2 + 2.0d0 * tmprho * dcos ( t ( j )) + 1.0d0 ) end if end do end do !$omp end do !$omp end parallel !-- Set total number for unknown variables in a_k if ( nrot > 0 ) then !-- nk = free variable + boundary variable (=nbound) !-- all arrays and matrices are composed of nk + nbound !-- The last \"nbound\" is asigned for \"lambda\" (i.e., additional constraints) nk = ( 2 + 2 * nrot ) * ( nr - 1 ) + 2 + 2 + ndiv * nrdiv + ( 2 * nrot - 1 ) nbound = 2 * nrot - 1 else nk = 2 * ( nr - 1 ) + 2 + ndiv * nrdiv nbound = 0 end if !-- Allocate and initialize arrays allocate ( Vdivr_r ( nr ), stat = cstat ) allocate ( Vrott_r ( nr ), stat = cstat ) allocate ( phis_nr ( nrot , nr + 1 ), stat = cstat ) allocate ( phic_nr ( nrot , nr + 1 ), stat = cstat ) allocate ( divc_mr ( ndiv , nrdiv ), stat = cstat ) allocate ( x_k ( nk + nbound ), stat = cstat ) allocate ( b_k ( nk + nbound ), stat = cstat ) allocate ( a_kp ( nk + nbound , nk + nbound ), stat = cstat ) allocate ( f_kij ( nk , nr , nt ), stat = cstat ) allocate ( undeflag ( nr , nt ), stat = cstat ) undeflag = . false . call check_undef_grid ( Vd , dundef , undeflag ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"Retrieve_velocity_GVTDX\" , - 1 ) stop end if Vdivr_r = 0.0d0 Vrott_r = 0.0d0 phis_nr = 0.0d0 phic_nr = 0.0d0 divc_mr = 0.0d0 x_k = 0.0d0 b_k = 0.0d0 a_kp = 0.0d0 f_kij = 0.0d0 !-- Calculate f_kij !-- ** normalized radius is used in r_n ** call calc_fkij ( nrot , ndiv , nk , Un , Vn , rtc_n , r_n , t , rh_n , td , rdiv_n , f_kij , Vd , undeflag ) !-- Calculate b_k call calc_fkijVd2bk ( vmax , f_kij , Vd , delta , b_k ( 1 : nk ), undeflag ) !-- Calculate a_kp call calc_fkij2akp ( f_kij , a_kp ( 1 : nk , 1 : nk ), undeflag ) call check_zero ( a_kp ( 1 : nk , 1 : nk ) ) !-- Set elements for additional constraints if ( nrot > 0 ) then do k = 1 , nbound a_kp ( nk + k , nk - nbound + k ) = 1.0d0 a_kp ( nk - nbound + k , nk + k ) = 1.0d0 end do b_k ( nk + 1 ) =- rh_n ( nr ) * ( Vn ( 2 ) - Vn ( 1 )) / vmax end if !-- Solve x_k call fp_gauss ( a_kp , b_k , x_k ) !-- Set each unknown variable from x_k call set_xk2variables ( nrot , ndiv , nrdiv , Un , Vn , vmax , & & x_k ( 1 : nk ), Vrott_r , Vdivr_r , & & phis_nr , phic_nr , divc_mr , undef = dundef ) !-- Calculate Vr and Vt components of rotating wind call calc_phi2Vrot ( nrot , Un , Vn , vmax , r_n , rh_n , t , & & Vrott_r , VRT0 , VRTn , VRRn , phis_nr , phic_nr , & & undef = dundef ) !-- Calculate Vr and Vt components of divergent wind call calc_D2Vdiv ( ndiv , vmax , r_n , rh_n , t , rdiv_n , Vdivr_r , & & VDR0 , VDTm , VDRm , divc_mr , undef = dundef ) !-- Calculate total retrieved Vr and Vt call calc_Vn2Vtot ( nrot , ndiv , VRT0 , VRTn , VDTm , VT ) call calc_Vn2Vtot ( nrot , ndiv , VDR0 , VRRn , VDRm , VR ) !-- Set undef in each output variable at undefined grids call set_undef_value ( undeflag , dundef , VT ) call set_undef_value ( undeflag , dundef , VR ) if ( nrot > 0 ) then do k = 1 , nrot call set_undef_value ( undeflag , dundef , VRTn ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VRRn ( k , 1 : nr , 1 : nt ) ) end do end if if ( ndiv > 0 ) then do k = 1 , ndiv call set_undef_value ( undeflag , dundef , VDTm ( k , 1 : nr , 1 : nt ) ) call set_undef_value ( undeflag , dundef , VDRm ( k , 1 : nr , 1 : nt ) ) end do end if !-- monitor variables if (( present ( phin )). and .( nrot > 0 )) then call calc_Phi2Phin ( nrot , vmax , rh ( nr + 1 ), r_n , rh_n , t , phis_nr , phic_nr , phin ) end if if (( present ( zetan )). and .( nrot > 0 )) then call calc_Phi2Zetan ( nrot , vmax , rh ( nr + 1 ), r_n , rh_n , t , phis_nr , phic_nr , zetan ) end if if ( present ( VRT0_GVTD ). and .( nrot > 0 )) then call calc_pseudo_GVTD0 ( nrot , vmax , rtc_n , r_n , rh_n , VRT0 ( 1 : nr , 1 ), VDR0 ( 1 : nr , 1 ), & & phis_nr , phic_nr , GVTDV_r ( 1 : nr ), GVTDU_r ( 1 : nr ) ) do i = 1 , nr VRT0_GVTD ( i , 1 : nt ) = GVTDV_r ( i ) VDR0_GVTD ( i , 1 : nt ) = GVTDU_r ( i ) end do end if if ( present ( VRTns ). and .( nrot > 0 )) then call calc_phi2sc ( nrot , vmax , r_n , rh_n , phis_nr , phic_nr , & & VRTns_r ( 1 : nrot , 1 : nr ), VRTnc_r ( 1 : nrot , 1 : nr ), & & VRRns_r ( 1 : nrot , 1 : nr ), VRRnc_r ( 1 : nrot , 1 : nr ) ) do k = 1 , nrot do i = 1 , nr VRTns ( k , i , 1 : nt ) = VRTns_r ( k , i ) VRTnc ( k , i , 1 : nt ) = VRTnc_r ( k , i ) VRRns ( k , i , 1 : nt ) = VRRns_r ( k , i ) VRRnc ( k , i , 1 : nt ) = VRRnc_r ( k , i ) end do end do end if call stdout ( \"Finish procedure.\" , \"Retrieve_velocity_GVTDX\" , 0 ) end subroutine Retrieve_velocity_GVTDX subroutine calc_fkij ( nrot , ndiv , nnk , Usrn , Vsrn , rtc , rd , theta , rdh , thetad , rddiv , & & fkij , Vdij , undeflag ) !! Calculate the coefficient matrix f_{kij} implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber for stream function integer , intent ( in ) :: ndiv !! Maximum wavenumber for velocity potential integer , intent ( in ) :: nnk !! Matrix dimension for fkij double precision , intent ( in ) :: Usrn ( 2 ) !! Environmental wind (not use) double precision , intent ( in ) :: Vsrn ( 2 ) !! Environmental wind normal to radar [m/s] double precision , intent ( in ) :: rtc !! Distance between the radar to vortex center [m] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: thetad ( size ( rd ), size ( theta )) !! \\theta_d  double precision , intent ( in ) :: rddiv (:) !! Normalized radius of the defined point for divergence [1] double precision , intent ( out ) :: fkij ( nnk , size ( rd ), size ( theta )) !! Coefficient matrix double precision , intent ( inout ) :: Vdij ( size ( rd ), size ( theta )) !! Doppler velocity [m/s] logical , intent ( in ) :: undeflag ( size ( rd ), size ( theta )) !! Undefined flag at each sampling point !-- internal variables integer :: nnr , nnt , nnrdiv , nnrdiv2 , ii , jj , kk , pp , nmax , cstat , ncyc double precision :: r1_out_coef !MOD, r_infty double precision , dimension ( size ( rd )) :: dr , dr_inv , alp double precision , dimension ( size ( rd )) :: r_inv double precision , dimension ( size ( rd ), size ( theta )) :: sines , cosines double precision , allocatable , dimension (:,:) :: sinen , cosinen double precision , allocatable , dimension (:,:,:) :: gkrr call stdout ( \"Enter procedure.\" , \"calc_fkij\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) nnrdiv2 = size ( rddiv ) nnrdiv = nnrdiv2 / 2 ncyc = 2 + 2 * nrot ! unknown variable number at a certain radius nmax = max ( max ( 0 , nrot ), ndiv ) ! maximum wave number for rotating and divergent components fkij = 0.0d0 if ( nmax > 0 ) then allocate ( sinen ( nmax , nnt ), stat = cstat ) allocate ( cosinen ( nmax , nnt ), stat = cstat ) allocate ( gkrr ( nmax , nnrdiv2 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rd if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkij\" , - 1 ) stop end if sinen = 0.0d0 cosinen = 0.0d0 gkrr = 0.0d0 end if if ( nrot > 0 ) then if ( nnk /= ncyc * ( nnr - 1 ) + 2 + 2 + ndiv * nnrdiv + 2 * nrot - 1 ) then call stdout ( \"nnk is not identical to (2+2N)(m-1)+2+2+M*(mm-1). stop.\" , \"calc_fkij\" , - 1 ) stop end if else if ( nnk /= ncyc * ( nnr - 1 ) + 2 + ndiv * nnrdiv ) then call stdout ( \"nnk is not identical to (2+2N)(m-1)+2+M*(mm-1). stop.\" , \"calc_fkij\" , - 1 ) stop end if end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) r_inv ( ii ) = 1.0d0 / rd ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !-- Set fixed variables for R-T, in advance !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr sines ( ii , jj ) = rtc * r_inv ( ii ) * dsin ( theta ( jj )) ! MOD = delta x sin(theta-thetad) cosines ( ii , jj ) = 1.0d0 + rtc * r_inv ( ii ) * dcos ( theta ( jj )) ! MOD = delta x cos(theta-thetad) end do end do !$omp end do !$omp barrier if ( nmax > 0 ) then !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , nmax sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnrdiv2 ! For rdiv do kk = 1 , nmax gkrr ( kk , ii , jj ) = green_func ( rddiv ( ii ), rd ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnrdiv2 ! For rddiv do kk = 1 , nmax gkrr ( kk , ii , nnr + 1 ) = green_func ( rddiv ( ii ), rd ( nnr ) + dr ( nnr ), kk ) end do end do !$omp end do end if !$omp barrier !-- Set coefficients for VRT0 at each (ii,jj) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr fkij ( 1 + ncyc * ( ii - 1 ), ii , jj ) =- sines ( ii , jj ) end do end do !$omp end do !$omp barrier !-- Set coefficients for VDR0 at each (ii,jj) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr fkij ( 2 + ncyc * ( ii - 1 ), ii , jj ) = cosines ( ii , jj ) end do end do !$omp end do !$omp barrier if ( nrot > 0 ) then !-- Set coefficients for Phi_s and Phi_c at each (ii,jj) for wavenumber 1 !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnt do ii = 1 , nnr - 2 !-- Phi(s)*delta(s,i) fkij ( 2 + 1 + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( 1 , jj )) & & * ( - sines ( ii , jj )) & & + (( 1.0d0 - alp ( ii )) * dble ( 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i) fkij ( 2 + nrot + 1 + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( 1 , jj )) & & * ( - sines ( ii , jj )) & & - (( 1.0d0 - alp ( ii )) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(s)*delta(s,i+1) fkij ( 2 + 1 + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( 1 , jj )) & & * ( sines ( ii , jj )) & & + ( alp ( ii ) * dble ( 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i+1) fkij ( 2 + nrot + 1 + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( 1 , jj )) & & * ( sines ( ii , jj )) & & - ( alp ( ii ) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) end do end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c !--     at one inner radius from the outermost (nnr-1,jj) for wavenumber 1 !$omp do schedule(runtime) private(jj) do jj = 1 , nnt !-- Phi(s)*delta(s,nnr-2) fkij ( 2 + 1 + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( 1 , jj )) * ( - sines ( nnr - 1 , jj )) & & + (( 1.0d0 - alp ( nnr - 1 )) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr-2) fkij ( 2 + nrot + 1 + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( 1 , jj )) * ( - sines ( nnr - 1 , jj )) & & - (( 1.0d0 - alp ( nnr - 1 )) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + 1 + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( 1 , jj )) * ( sines ( nnr - 1 , jj )) & & + ( alp ( nnr - 1 ) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr-1) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + 1 + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( 1 , jj )) * ( sines ( nnr - 1 , jj )) & & - ( alp ( nnr - 1 ) * dble ( 1 ) * sinen ( 1 , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c !--     at the outermost (nnr,jj) for wavenumber 1 !$omp do schedule(runtime) private(jj) do jj = 1 , nnt !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + 1 + ncyc * ( nnr - 1 ), nnr , jj ) & & = ( dr_inv ( nnr ) * sinen ( 1 , jj )) * ( - sines ( nnr , jj )) & & + (( 1.0d0 - alp ( nnr )) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr ) * cosines ( nnr , jj )) !-- Phi(s)*delta(s,nnr) fkij ( 2 + 2 + ncyc * ( nnr - 1 ), nnr , jj ) & & = ( dr_inv ( nnr ) * sinen ( 1 , jj )) * ( sines ( nnr , jj )) & & + ( alp ( nnr ) * cosinen ( 1 , jj )) & & * ( r_inv ( nnr ) * cosines ( nnr , jj )) if ( undeflag ( nnr , jj ). eqv .. false .) then ! Remove WN-1 Vm at the outermost radius Vdij ( nnr , jj ) & & = Vdij ( nnr , jj ) & & - ( Vsrn ( 2 ) - Vsrn ( 1 )) * ( - cosinen ( 1 , jj ) * sines ( nnr , jj ) & & + sinen ( 1 , jj ) * cosines ( nnr , jj )) end if end do !$omp end do !$omp barrier !-- 2. For wavenumber >= 2 if ( nrot > 1 ) then !-- Set coefficients for Phi_s and Phi_c at each (ii,jj) !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr - 2 do kk = 2 , nrot !-- Phi(s)*delta(s,i) fkij ( 2 + kk + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( kk , jj )) & & * ( - sines ( ii , jj )) & & + (( 1.0d0 - alp ( ii )) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i) fkij ( 2 + nrot + kk + ncyc * ( ii - 1 ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( kk , jj )) & & * ( - sines ( ii , jj )) & & - (( 1.0d0 - alp ( ii )) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(s)*delta(s,i+1) fkij ( 2 + kk + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * sinen ( kk , jj )) & & * ( sines ( ii , jj )) & & + ( alp ( ii ) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) !-- Phi(c)*delta(s,i+1) fkij ( 2 + nrot + kk + ncyc * ( ii ), ii , jj ) & & = ( dr_inv ( ii ) * cosinen ( kk , jj )) & & * ( sines ( ii , jj )) & & - ( alp ( ii ) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( ii ) * cosines ( ii , jj )) end do end do end do !$omp end do !$omp barrier !-- Set coefficients for Phi_s and Phi_c at one inner radius from the outermost (nnr-1,jj) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 2 , nrot !-- Phi(s)*delta(s,nnr-1) fkij ( 2 + kk + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & =- dr_inv ( nnr - 1 ) * sinen ( kk , jj ) * sines ( nnr - 1 , jj ) & & + ( 1.0d0 - alp ( nnr - 1 )) * dble ( kk ) * cosinen ( kk , jj ) & & * r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj ) !-- Phi(c)*delta(s,nnr-1) fkij ( 2 + nrot + kk + ncyc * ( nnr - 2 ), nnr - 1 , jj ) & & =- dr_inv ( nnr - 1 ) * cosinen ( kk , jj ) * sines ( nnr - 1 , jj ) & & - ( 1.0d0 - alp ( nnr - 1 )) * dble ( kk ) * sinen ( kk , jj ) & & * r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj ) !-- Phi(s)*delta(s,nnr) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + kk + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * sinen ( kk , jj )) & & * ( sines ( nnr - 1 , jj )) & & + ( alp ( nnr - 1 ) * dble ( kk ) * cosinen ( kk , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) !-- Phi(c)*delta(s,nnr) (related to the outermost radius) fkij ( 2 + 2 + ndiv * nnrdiv + nrot - 1 + kk + ncyc * ( nnr - 1 ), nnr - 1 , jj ) & & = ( dr_inv ( nnr - 1 ) * cosinen ( kk , jj )) & & * ( sines ( nnr - 1 , jj )) & & - ( alp ( nnr - 1 ) * dble ( kk ) * sinen ( kk , jj )) & & * ( r_inv ( nnr - 1 ) * cosines ( nnr - 1 , jj )) end do end do !$omp end do end if end if !$omp barrier if ( ndiv > 0 ) then !-- Set coefficients for D_s and D_c at each (ii,jj) !$omp do schedule(runtime) private(kk,pp,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do pp = 1 , nnrdiv do kk = 1 , ndiv fkij ( ncyc * ( nnr - 1 ) + 2 + 2 + kk + ndiv * ( pp - 1 ), ii , jj ) & & =- ( r_inv ( ii ) * dble ( kk ) * 0.5d0 * ( rddiv ( 2 * pp ) - rddiv ( 2 * pp - 1 )) & ! For Dc & * ( rddiv ( 2 * pp ) * gkrr ( kk , 2 * pp , ii ) + rddiv ( 2 * pp - 1 ) * gkrr ( kk , 2 * pp - 1 , ii )) & & * sinen ( kk , jj ) * sines ( ii , jj ) & & + 0.5d0 * ( rddiv ( 2 * pp ) - rddiv ( 2 * pp - 1 )) * dr_inv ( ii ) & & * ( rddiv ( 2 * pp ) * ( gkrr ( kk , 2 * pp , ii + 1 ) - gkrr ( kk , 2 * pp , ii )) & & + rddiv ( 2 * pp - 1 ) * ( gkrr ( kk , 2 * pp - 1 , ii + 1 ) - gkrr ( kk , 2 * pp - 1 , ii ))) & & * cosinen ( kk , jj ) * cosines ( ii , jj )) end do end do end do end do !$omp end do !$omp barrier end if !$omp end parallel if ( nmax > 0 ) then deallocate ( sinen ) deallocate ( cosinen ) deallocate ( gkrr ) end if call stdout ( \"Finish procedure.\" , \"calc_fkij\" , 0 ) end subroutine calc_fkij subroutine calc_fkij2akp ( fkij , akp , undeflag ) !! Calculation of the coefficient matrix A  in LSM from f_{k,i,j} implicit none double precision , intent ( in ) :: fkij (:,:,:) !! Coefficient matrix double precision , intent ( out ) :: akp ( size ( fkij , 1 ), size ( fkij , 1 )) !! Coefficient matrix in LSM logical , intent ( in ) :: undeflag ( size ( fkij , 2 ), size ( fkij , 3 )) !! Undefined flag at each sampling point integer :: nnk , nni , nnj , ii , jj , kk , ll , cstat double precision , allocatable , dimension (:,:,:) :: fkl , fpl !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"calc_fkij2akp\" , 0 ) nnk = size ( fkij , 1 ) nni = size ( fkij , 2 ) nnj = size ( fkij , 3 ) ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( fkl ( nni , nnj , ompnum ), stat = cstat ) allocate ( fpl ( nni , nnj , ompnum ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkij2akp\" , - 1 ) stop end if do ll = 1 , nnk !$omp parallel default(shared) !$omp do schedule(dynamic) private(kk,omppe) do kk = ll , nnk !$      omppe=OMP_GET_THREAD_NUM()+1 fkl ( 1 : nni , 1 : nnj , omppe ) = fkij ( kk , 1 : nni , 1 : nnj ) fpl ( 1 : nni , 1 : nnj , omppe ) = fkij ( ll , 1 : nni , 1 : nnj ) akp ( kk , ll ) = matrix_sum ( fkl ( 1 : nni , 1 : nnj , omppe ), fpl ( 1 : nni , 1 : nnj , omppe ), & & undeflag ( 1 : nni , 1 : nnj ) ) akp ( ll , kk ) = akp ( kk , ll ) end do !$omp end do !$omp end parallel end do deallocate ( fkl ) deallocate ( fpl ) call stdout ( \"Finish procedure.\" , \"calc_fkij2akp\" , 0 ) end subroutine calc_fkij2akp subroutine calc_fkijVd2bk ( vmax , fkij , Vdl , deltaij , bk , undeflag ) !! Calculate the vector b_k  from f_{k,i,j} and V_d) implicit none double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: fkij (:,:,:) !! Coefficient matrix double precision , intent ( in ) :: Vdl ( size ( fkij , 2 ), size ( fkij , 3 )) !! Doppler velocity [m/s] double precision , intent ( in ) :: deltaij ( size ( fkij , 2 ), size ( fkij , 3 )) !! Geometric coefficient: (=\\delta /\\rho ) double precision , intent ( out ) :: bk ( size ( fkij , 1 )) !! Vector \\textbf{b} logical , intent ( in ) :: undeflag ( size ( fkij , 2 ), size ( fkij , 3 )) !! Undefined flag at each sampling point integer :: nnk , nni , nnj , ii , jj , kk , ll , cstat double precision , allocatable , dimension (:,:,:) :: fkl double precision :: dVdl ( size ( fkij , 2 ), size ( fkij , 3 )) !-- OpenMP variables !$ integer :: OMP_GET_THREAD_NUM, OMP_GET_MAX_THREADS integer :: ompnum , omppe call stdout ( \"Enter procedure.\" , \"calc_fkijVd2bk\" , 0 ) nnk = size ( fkij , 1 ) nni = size ( fkij , 2 ) nnj = size ( fkij , 3 ) ompnum = 1 omppe = 1 !$   ompnum=OMP_GET_MAX_THREADS() allocate ( fkl ( nni , nnj , ompnum ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_fkijVd2bk\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(ii,jj) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then dVdl ( ii , jj ) = Vdl ( ii , jj ) else dVdl ( ii , jj ) = deltaij ( ii , jj ) * Vdl ( ii , jj ) end if end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,omppe) do kk = 1 , nnk !$   omppe=OMP_GET_THREAD_NUM()+1 fkl ( 1 : nni , 1 : nnj , omppe ) = fkij ( kk , 1 : nni , 1 : nnj ) bk ( kk ) = matrix_sum ( dVdl ( 1 : nni , 1 : nnj ), fkl ( 1 : nni , 1 : nnj , omppe ), & & undeflag ( 1 : nni , 1 : nnj ) ) / vmax end do !$omp end do !$omp end parallel deallocate ( fkl ) call stdout ( \"Finish procedure.\" , \"calc_fkijVd2bk\" , 0 ) end subroutine calc_fkijVd2bk subroutine set_xk2variables ( nrot , ndiv , nnrdiv , Usrn , Vsrn , vmax , & & xk , VRT0 , VDR0 , & & phis_n , phic_n , Ds_m , undef ) !! Set each unknown variable from the solved x_k implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber of stream function integer , intent ( in ) :: ndiv !! Maximum wavenumber of velocity potential integer , intent ( in ) :: nnrdiv !! Radial grid number for divergence double precision , intent ( in ) :: Usrn ( 2 ) !! Environmental wind (not use) double precision , intent ( in ) :: Vsrn ( 2 ) !! Environmental wind normal to radar [m/s] double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: xk (:) !! Solved unknown variable vector double precision , intent ( out ) :: VRT0 (:) !! Wavenumber-0 tangential wind [m/s] double precision , intent ( out ) :: VDR0 ( size ( VRT0 )) !! Wavenumber-0 radial wind [m/s] double precision , intent ( out ), optional :: phis_n ( nrot , size ( VRT0 ) + 1 ) !! Sine components of stream function [m&#94;2/s] double precision , intent ( out ), optional :: phic_n ( nrot , size ( VRT0 ) + 1 ) !! Cosine components of stream function [m&#94;2/s] double precision , intent ( out ), optional :: Ds_m ( ndiv , nnrdiv ) !! Divergence [s-1] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , kk , nnk , nnr , ncyc double precision :: Usrn_n ( 2 ), Vsrn_n ( 2 ) call stdout ( \"Enter procedure.\" , \"set_xk2variables\" , 0 ) nnk = size ( xk ) nnr = size ( VRT0 ) ncyc = 2 + 2 * nrot Usrn_n ( 1 : 2 ) = Usrn ( 1 : 2 ) / vmax Vsrn_n ( 1 : 2 ) = Vsrn ( 1 : 2 ) / vmax !-- Set VRT0 and VDR0 do ii = 1 , nnr - 1 VRT0 ( ii ) = xk ( 1 + ncyc * ( ii - 1 )) VDR0 ( ii ) = xk ( 2 + ncyc * ( ii - 1 )) end do VRT0 ( nnr ) = xk ( 1 + ncyc * ( nnr - 1 )) VDR0 ( nnr ) = xk ( 2 + ncyc * ( nnr - 1 )) !-- Set Phi_s and Phi_c if ( nrot > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr - 1 do kk = 1 , nrot phis_n ( kk , ii ) = xk ( 2 + kk + ncyc * ( ii - 1 )) phic_n ( kk , ii ) = xk ( 2 + nrot + kk + ncyc * ( ii - 1 )) end do end do !$omp end do !$omp end parallel phis_n ( 1 , nnr ) = xk ( 2 + 1 + ncyc * ( nnr - 1 )) phis_n ( 1 , nnr + 1 ) = xk ( 2 + 2 + ncyc * ( nnr - 1 )) end if !-- Set D_s and D_c if ( ndiv > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnrdiv do kk = 1 , ndiv Ds_m ( kk , ii ) = xk ( ncyc * ( nnr - 1 ) + 2 + 2 + kk + ndiv * ( ii - 1 )) end do end do !$omp end do !$omp end parallel end if call stdout ( \"Finish procedure.\" , \"set_xk2variables\" , 0 ) end subroutine set_xk2variables subroutine calc_phi2Vrot ( nrot , Usrn , Vsrn , vmax , rd , rdh , theta , VRT0_r , & & VRT0_rt , VRT_nrt , VRR_nrt , & & phis_nr , phic_nr , undef ) !! Calculate radial and tangential components of rotating wind implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber of stream function double precision , intent ( in ) :: Usrn ( 2 ) !! Environmental wind (not use) double precision , intent ( in ) :: Vsrn ( 2 ) !! Environmental wind normal to radar [m/s] double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: VRT0_r ( size ( rd )) !! Wavenumber-0 tangential wind [m/s] double precision , intent ( out ) :: VRT0_rt ( size ( rd ), size ( theta )) !! = VRT0_r double precision , intent ( out ), optional :: VRT_nrt ( nrot , size ( rd ), size ( theta )) !! Tangential components of rotating wind for each wavenumber double precision , intent ( out ), optional :: VRR_nrt ( nrot , size ( rd ), size ( theta )) !! Radial components of rotating wind for each wavenumber double precision , intent ( inout ), optional :: phis_nr ( nrot , size ( rd ) + 1 ) !! Sine components of stream function double precision , intent ( inout ), optional :: phic_nr ( nrot , size ( rd ) + 1 ) !! Cosine components of stream function double precision , intent ( in ), optional :: undef !! No use integer :: ii , jj , kk , nnr , nnt , cstat double precision :: Usrn_n ( 2 ), Vsrn_n ( 2 ) double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp double precision , allocatable , dimension (:,:) :: cosinen , sinen call stdout ( \"Enter procedure.\" , \"calc_phi2Vrot\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) if ( nrot > 0 ) then allocate ( cosinen ( nrot , nnt ), stat = cstat ) allocate ( sinen ( nrot , nnt ), stat = cstat ) if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_phi2Vrot\" , - 1 ) stop end if !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , nrot cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp end parallel end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) Usrn_n ( 1 : 2 ) = Usrn ( 1 : 2 ) / vmax Vsrn_n ( 1 : 2 ) = Vsrn ( 1 : 2 ) / vmax do ii = 1 , nnr VRT0_rt ( ii , 1 : nnt ) = VRT0_r ( ii ) * vmax end do if ( nrot > 0 ) then VRT_nrt = 0.0d0 VRR_nrt = 0.0d0 !-- set the outermost boundary for wavenumber 1 phic_nr ( 1 , nnr + 1 ) =- rdh ( nnr + 1 ) * ( Vsrn_n ( 2 ) - Vsrn_n ( 1 )) phic_nr ( 1 , nnr ) =- rdh ( nnr ) * ( Vsrn_n ( 2 ) - Vsrn_n ( 1 )) !-- set the outermost boundary for wavenumber 2 if ( nrot > 1 ) then do kk = 2 , nrot phis_nr ( kk , nnr + 1 ) = 0.0d0 phic_nr ( kk , nnr + 1 ) = 0.0d0 phis_nr ( kk , nnr ) = 0.0d0 phic_nr ( kk , nnr ) = 0.0d0 end do end if !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot VRT_nrt ( kk , ii , jj ) =- dr_inv ( ii ) * (( phis_nr ( kk , ii + 1 ) - phis_nr ( kk , ii )) * sinen ( kk , jj ) & & + ( phic_nr ( kk , ii + 1 ) - phic_nr ( kk , ii )) * cosinen ( kk , jj )) VRR_nrt ( kk , ii , jj ) = dble ( kk ) * r_inv ( ii ) & & * (( alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii )) * cosinen ( kk , jj ) & & - ( alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii )) * sinen ( kk , jj )) VRT_nrt ( kk , ii , jj ) = VRT_nrt ( kk , ii , jj ) * vmax VRR_nrt ( kk , ii , jj ) = VRR_nrt ( kk , ii , jj ) * vmax end do end do end do !$omp end do !$omp end parallel end if if ( nrot > 0 ) then deallocate ( cosinen ) deallocate ( sinen ) end if call stdout ( \"Finish procedure.\" , \"calc_phi2Vrot\" , 0 ) end subroutine calc_phi2Vrot subroutine calc_D2Vdiv ( ndiv , vmax , rd , rdh , theta , rddiv , VDR0_r , & & VDR0_rt , VDT_mrt , VDR_mrt , Ds_mr , undef ) !! Calculate radial and tangential components of divergent wind implicit none integer , intent ( in ) :: ndiv !! Maximum wavenumber of velocity potential double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rd (:) !! Nomalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: rddiv (:) !! Normalized radius for defined grid of divergence [1] double precision , intent ( in ) :: VDR0_r ( size ( rd )) !! Wavenumber-0 radial wind [m/s] double precision , intent ( out ) :: VDR0_rt ( size ( rd ), size ( theta )) !! = VDR0_r double precision , intent ( out ), optional :: VDT_mrt ( ndiv , size ( rd ), size ( theta )) !! Tangential components of divergent wind for each wavenumber [m/s] double precision , intent ( out ), optional :: VDR_mrt ( ndiv , size ( rd ), size ( theta )) !! Radial components of divergent wind for each wavenumber [m/s] double precision , intent ( in ), optional :: Ds_mr ( ndiv , size ( rddiv )) !! Divergence [1/s] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , kk , nnr , nnt , nnrdiv , nnrdiv2 , cstat , irad !  double precision :: rmax_inv double precision , dimension ( size ( rd )) :: dr_inv , dr , r_inv double precision , allocatable , dimension (:,:) :: cosinen , sinen double precision , allocatable , dimension (:,:,:) :: gkrr , gkrrh , dgkrr double precision :: tmp_Ds_mr ( ndiv , size ( rd ) + 1 ) call stdout ( \"Enter procedure.\" , \"calc_D2Vdiv\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) nnrdiv2 = size ( rddiv ) nnrdiv = nnrdiv2 / 2 if ( ndiv > 0 ) then allocate ( cosinen ( ndiv , nnt ), stat = cstat ) allocate ( sinen ( ndiv , nnt ), stat = cstat ) allocate ( gkrr ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rdh allocate ( gkrrh ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r), r_p at rdh, r at rdh allocate ( dgkrr ( ndiv , nnr + 1 , nnr + 1 ), stat = cstat ) ! Gk(r_p,r+1)-Gk(r_p,r), r_p at rdh, r at rdh if ( cstat /= 0 ) then call stdout ( \"Failed to allocate variables. stop.\" , \"calc_D2Vdiv\" , - 1 ) stop end if cosinen = 0.0d0 sinen = 0.0d0 gkrr = 0.0d0 gkrrh = 0.0d0 dgkrr = 0.0d0 tmp_Ds_mr = 0.0d0 do kk = 1 , ndiv do ii = 1 , nnrdiv call interpo_search_1d ( rdh , rddiv ( 2 * ii - 1 ), irad ) tmp_Ds_mr ( kk , irad ) = Ds_mr ( kk , ii ) call interpo_search_1d ( rdh , rddiv ( 2 * ii ), irad ) tmp_Ds_mr ( kk , irad ) = Ds_mr ( kk , ii ) end do end do end if do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) do ii = 1 , nnr VDR0_rt ( ii , 1 : nnt ) = VDR0_r ( ii ) * vmax end do if ( ndiv > 0 ) then VDT_mrt = 0.0d0 VDR_mrt = 0.0d0 !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,jj) do jj = 1 , nnt do kk = 1 , ndiv cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrr ( kk , ii , jj ) = green_func ( rdh ( ii ), rd ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) ! At the outer boundary for r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrr ( kk , ii , nnr + 1 ) = green_func ( rdh ( ii ), rdh ( nnr + 1 ), kk ) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr + 1 ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv gkrrh ( kk , ii , jj ) = green_func ( rdh ( ii ), rdh ( jj ), kk ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnr ! For r do ii = 1 , nnr + 1 ! For r_p do kk = 1 , ndiv dgkrr ( kk , ii , jj ) = gkrr ( kk , ii , jj + 1 ) - gkrr ( kk , ii , jj ) end do end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , ndiv VDT_mrt ( kk , ii , jj ) =- ( dr ( ii ) * dble ( kk ) * r_inv ( ii ) * vmax ) & & * ( - line_integral ( nnr , rdh ( 1 : nnr + 1 ), gkrr ( kk , 1 : nnr + 1 , ii ), tmp_Ds_mr ( kk , 1 : nnr + 1 ) ) & & * sinen ( kk , jj )) VDR_mrt ( kk , ii , jj ) =- ( vmax ) & & * ( + line_integral ( nnr , rdh ( 1 : nnr + 1 ), dgkrr ( kk , 1 : nnr + 1 , ii ), tmp_Ds_mr ( kk , 1 : nnr + 1 ) ) & & * cosinen ( kk , jj )) end do end do end do !$omp end do !$omp end parallel end if if ( ndiv > 0 ) then deallocate ( cosinen ) deallocate ( sinen ) deallocate ( gkrr ) deallocate ( gkrrh ) deallocate ( dgkrr ) end if call stdout ( \"Finish procedure.\" , \"calc_D2Vdiv\" , 0 ) end subroutine calc_D2Vdiv subroutine calc_Vn2Vtot ( nrot , ndiv , V0 , Vn , Vm , Vtot , undef ) !! Calculate (radial or tangential) total wind from all wavenumbers implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber for stream function integer , intent ( in ) :: ndiv !! Maximum wavenumber for velocity potential double precision , intent ( in ) :: V0 (:,:) !! Wavenumber-0 component [m/s] double precision , intent ( in ) :: Vn ( nrot , size ( V0 , 1 ), size ( V0 , 2 )) !! rotating components [m/s] double precision , intent ( in ) :: Vm ( ndiv , size ( V0 , 1 ), size ( V0 , 2 )) !! divergent components [m/s] double precision , intent ( inout ) :: Vtot ( size ( V0 , 1 ), size ( V0 , 2 )) !! Total wind [m/s] double precision , intent ( in ), optional :: undef !! Undefined value integer :: ii , jj , kk , nnr , nnt call stdout ( \"Enter procedure.\" , \"calc_Vn2Vtot\" , 0 ) nnr = size ( V0 , 1 ) nnt = size ( V0 , 2 ) Vtot = V0 if ( present ( undef )) then do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot if ( Vn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vn ( kk , ii , jj ) end if end do do kk = 1 , ndiv if ( Vn ( kk , ii , jj ) /= undef ) then Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vm ( kk , ii , jj ) end if end do end do end do else do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vn ( kk , ii , jj ) end do do kk = 1 , ndiv Vtot ( ii , jj ) = Vtot ( ii , jj ) + Vm ( kk , ii , jj ) end do end do end do end if call stdout ( \"Finish procedure.\" , \"calc_Vn2Vtot\" , 0 ) end subroutine calc_Vn2Vtot double precision function dot_prod ( v1 , v2 ) !! Calculate inner product of two vectors implicit none double precision , intent ( in ) :: v1 (:) !! Vector 1 double precision , intent ( in ) :: v2 ( size ( v1 )) ! Vector 2 integer :: ii , ni double precision :: res ni = size ( v1 ) res = 0.0d0 do ii = 1 , ni res = res + v1 ( ii ) * v2 ( ii ) end do dot_prod = res return end function dot_prod double precision function matrix_sum ( aij , akj , undeflag ) !! Calculate product for a component in a matrix implicit none double precision , intent ( in ) :: aij (:,:) !! Matrix A1 double precision , intent ( in ) :: akj ( size ( aij , 1 ), size ( aij , 2 )) !! Matrix A2 logical , intent ( in ), optional :: undeflag ( size ( aij , 1 ), size ( aij , 2 )) !! Undefined flag at each sampling point integer :: ii , jj , ni , nj double precision :: res ni = size ( aij , 1 ) nj = size ( aij , 2 ) res = 0.0d0 if ( present ( undeflag )) then do jj = 1 , nj do ii = 1 , ni if ( undeflag ( ii , jj ). eqv .. false .) then res = res + aij ( ii , jj ) * akj ( ii , jj ) end if end do end do else do jj = 1 , nj do ii = 1 , ni res = res + aij ( ii , jj ) * akj ( ii , jj ) end do end do end if matrix_sum = res return end function matrix_sum subroutine check_zero ( a ) !! Check zero components in the matrix \"a\" implicit none double precision , intent ( in ) :: a (:,:) !! Matrix a integer :: ii , jj , nni , nnj logical :: res nni = size ( a , 1 ) nnj = size ( a , 2 ) do jj = 1 , nnj res = . false . do ii = 1 , nni if ( a ( ii , jj ) /= 0.0d0 ) then res = . true . exit end if end do if ( res . eqv .. false .) then write ( * , * ) \"Detect all zero\" , jj end if end do end subroutine check_zero subroutine check_undef_grid ( vval , undefv , undeflag ) !! Check undefined grids implicit none double precision , intent ( in ) :: vval (:,:) !! Grid value double precision , intent ( in ) :: undefv !! Undefined value logical , intent ( out ) :: undeflag ( size ( vval , 1 ), size ( vval , 2 )) ! Undefined flag integer :: ii , jj , nni , nnj nni = size ( vval , 1 ) nnj = size ( vval , 2 ) undeflag = . false . do jj = 1 , nnj do ii = 1 , nni if ( vval ( ii , jj ) == undefv ) then undeflag ( ii , jj ) = . true . end if end do end do end subroutine check_undef_grid subroutine set_undef_value ( undeflag , undefv , vval ) !! Set undef value (=\"undefv\") to val if undeflag == true. implicit none logical , intent ( in ) :: undeflag (:,:) !! Undefined flag at each sampling point double precision , intent ( in ) :: undefv !! Undefined value double precision , intent ( inout ) :: vval ( size ( undeflag , 1 ), size ( undeflag , 2 )) !! Original value at each sampling point integer :: ii , jj , nni , nnj nni = size ( undeflag , 1 ) nnj = size ( undeflag , 2 ) do jj = 1 , nnj do ii = 1 , nni if ( undeflag ( ii , jj ). eqv .. true .) then vval ( ii , jj ) = undefv end if end do end do end subroutine set_undef_value subroutine calc_Phi2Phin ( nrot , vmax , rmax , rd , rdh , theta , phis_nr , phic_nr , phi_nr ) !! Calculate streamfunction for each wavenumber implicit none integer , intent ( in ) :: nrot !!! Maximum wavenumber for stream function double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rmax !! Scaling factor for radius [m] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) !! Sine components of stream function [m2/s] double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) !! Cosine components of stream function [m2/s] double precision , intent ( out ) :: phi_nr ( nrot , size ( rd ), size ( theta )) !! Stream function [m2/s] integer :: ii , jj , kk , nnr , nnt , cstat double precision , dimension ( size ( rd )) :: alp double precision , dimension ( nrot , size ( theta )) :: sinen , cosinen double precision :: phisi , phici call stdout ( \"Enter procedure.\" , \"calc_Phi2Phin\" , 0 ) nnr = size ( rd ) nnt = size ( theta ) !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do jj = 1 , nnt do kk = 1 , nrot sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp end parallel do ii = 1 , nnr alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii,jj,phisi,phici) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot phisi = alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii ) phici = alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii ) phi_nr ( kk , ii , jj ) = ( phisi * sinen ( kk , jj ) + phici * cosinen ( kk , jj )) * vmax * rmax end do end do end do !$omp end do !$omp end parallel call stdout ( \"Finish procedure.\" , \"calc_Phi2Phin\" , 0 ) end subroutine calc_Phi2Phin subroutine calc_Phi2Zetan ( nrot , vmax , rmax , rd , rdh , theta , phis_nr , phic_nr , zeta_nr ) !! Calculate vorticity for each wavenumber implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber for stream function double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rmax !! Scaling factor for radius [m] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: theta (:) !! Azimuthal angle [rad] double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) !! Sine components of stream function [m2/s] double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) !! Cosine components of stream function [m2/s] double precision , intent ( out ) :: zeta_nr ( nrot , size ( rd ), size ( theta )) !! Vorticity [1/s] integer :: ii , jj , kk , nnr , nnt , cstat double precision , dimension ( size ( rd )) :: alp double precision , dimension ( nrot , size ( rd ) + 1 ) :: d2psdr2 , d2pcdr2 , dpsdr , dpcdr , psinv , pcinv double precision , dimension ( nrot , size ( theta )) :: sinen , cosinen double precision , dimension ( nrot , 0 : size ( rd ) + 2 ) :: tmpphis , tmpphic double precision , dimension ( size ( rd ) + 1 ) :: drc_inv , drf_inv , drb_inv , rh_inv , rh2_inv double precision , dimension ( size ( rd )) :: r_inv double precision :: dpfs , dpfc , dpbs , dpbc , rmax_inv double precision :: d2psdr2i , dpsdri , d2pcdr2i , dpcdri , phisi , phici call stdout ( \"Enter procedure.\" , \"calc_Phi2Zetan\" , 0 ) if ( nrot < 1 ) then call stdout ( \"nrot is greater than 0. stop.\" , \"calc_Phi2Zetan\" , - 1 ) stop end if nnr = size ( rd ) nnt = size ( theta ) drc_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drc_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) drb_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drb_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) drf_inv ( 1 ) = 1.0d0 / ( rdh ( 2 ) - rdh ( 1 )) drf_inv ( nnr + 1 ) = 1.0d0 / ( rdh ( nnr + 1 ) - rdh ( nnr )) rh_inv ( nnr + 1 ) = 1.0 / rdh ( nnr + 1 ) if ( rdh ( 1 ) == 0.0d0 ) then rh_inv ( 1 ) = 0.0d0 end if if ( rd ( 1 ) == 0.0d0 ) then r_inv ( 1 ) = 0.0d0 end if do ii = 2 , nnr drc_inv ( ii ) = 1.0d0 / ( rdh ( ii + 1 ) - rdh ( ii - 1 )) drb_inv ( ii ) = 1.0d0 / ( rdh ( ii ) - rdh ( ii - 1 )) drf_inv ( ii ) = 1.0d0 / ( rdh ( ii + 1 ) - rdh ( ii )) rh_inv ( ii ) = 1.0d0 / rdh ( ii ) r_inv ( ii ) = 1.0d0 / rd ( ii ) end do rmax_inv = 1.0d0 / rmax rh2_inv = rh_inv ** 2 tmpphis ( 1 : nrot , 1 : nnr + 1 ) = phis_nr ( 1 : nrot , 1 : nnr + 1 ) tmpphic ( 1 : nrot , 1 : nnr + 1 ) = phic_nr ( 1 : nrot , 1 : nnr + 1 ) tmpphis ( 1 : nrot , 0 ) = phis_nr ( 1 : nrot , 1 ) ! dummy tmpphis ( 1 : nrot , nnr + 2 ) = phis_nr ( 1 : nrot , nnr + 1 ) ! dummy tmpphic ( 1 : nrot , 0 ) = phic_nr ( 1 : nrot , 1 ) ! dummy tmpphic ( 1 : nrot , nnr + 2 ) = phic_nr ( 1 : nrot , nnr + 1 ) ! dummy zeta_nr = 0.0d0 do ii = 1 , nnr alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do jj = 1 , nnt do kk = 1 , nrot sinen ( kk , jj ) = dsin ( dble ( kk ) * theta ( jj )) cosinen ( kk , jj ) = dcos ( dble ( kk ) * theta ( jj )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr + 1 do kk = 1 , nrot d2psdr2 ( kk , ii ) = 2.0d0 * drc_inv ( ii ) & & * (( tmpphis ( kk , ii + 1 ) - tmpphis ( kk , ii )) * drf_inv ( ii ) & & + ( tmpphis ( kk , ii - 1 ) - tmpphis ( kk , ii )) * drb_inv ( ii )) d2pcdr2 ( kk , ii ) = 2.0d0 * drc_inv ( ii ) & & * (( tmpphic ( kk , ii + 1 ) - tmpphic ( kk , ii )) * drf_inv ( ii ) & & + ( tmpphic ( kk , ii - 1 ) - tmpphic ( kk , ii )) * drb_inv ( ii )) dpsdr ( kk , ii ) = 0.5d0 * (( tmpphis ( kk , ii + 1 ) - tmpphis ( kk , ii )) * drf_inv ( ii ) & & - ( tmpphis ( kk , ii - 1 ) - tmpphis ( kk , ii )) * drb_inv ( ii )) dpcdr ( kk , ii ) = 0.5d0 * (( tmpphic ( kk , ii + 1 ) - tmpphic ( kk , ii )) * drf_inv ( ii ) & & - ( tmpphic ( kk , ii - 1 ) - tmpphic ( kk , ii )) * drb_inv ( ii )) end do end do !$omp end do !$omp barrier !$omp do schedule(runtime) private(kk,ii,jj,d2psdr2i,dpsdri,d2pcdr2i,dpcdri,phisi,phici) do jj = 1 , nnt do ii = 1 , nnr do kk = 1 , nrot phisi = alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii ) phici = alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii ) d2psdr2i = alp ( ii ) * d2psdr2 ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * d2psdr2 ( kk , ii ) dpsdri = alp ( ii ) * dpsdr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * dpsdr ( kk , ii ) d2pcdr2i = alp ( ii ) * d2pcdr2 ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * d2pcdr2 ( kk , ii ) dpcdri = alp ( ii ) * dpcdr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * dpcdr ( kk , ii ) zeta_nr ( kk , ii , jj ) = (( d2psdr2i + dpsdri * r_inv ( ii ) & & - (( dble ( kk ) * r_inv ( ii )) ** 2 ) * phisi ) & & * sinen ( kk , jj ) & & + ( d2pcdr2i + dpcdri * r_inv ( ii ) & & - (( dble ( kk ) * r_inv ( ii )) ** 2 ) * phici ) & & * cosinen ( kk , jj )) & & * vmax * rmax_inv end do end do end do !$omp end do !$omp end parallel call stdout ( \"Finish procedure.\" , \"calc_Phi2Zetan\" , 0 ) end subroutine calc_Phi2Zetan subroutine calc_pseudo_GVTD0 ( nrot , vmax , rtc , rd , rdh , VRT0_r , VDR0_r , & & phis_nr , phic_nr , VRT0_GVTD_r , VDR0_GVTD_r ) !! Calculate pseudo retrieval of VT and VR for GVTD implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber for stream function double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rtc !! Normalized distance between the radar to vortex center [1] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: VRT0_r ( size ( rd )) !! Wavenumber-0 tangential wind [m/s] double precision , intent ( in ) :: VDR0_r ( size ( rd )) !! Wanumber-0 radial wind [m/s] double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) !! Sine components of stream function [m2/s] double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) !! Cosine components of stream function [m2/s] double precision , intent ( out ) :: VRT0_GVTD_r ( size ( rd )) !! GVTD-reconstructed wavenumber-0 tangential wind [m/s] double precision , intent ( out ) :: VDR0_GVTD_r ( size ( rd )) !! GVTD-reconstructed wavenumber-0 radial wind [m/s] integer :: ii , jj , kk , nnr , cstat double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp double precision , dimension ( size ( rd )) :: tmp_VRT0_r , tmp_VDR0_r call stdout ( \"Enter procedure.\" , \"calc_pseudo_GVTD0\" , 0 ) nnr = size ( rd ) do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) tmp_VRT0_r ( 1 : nnr ) = VRT0_r ( 1 : nnr ) tmp_VDR0_r ( 1 : nnr ) = VDR0_r ( 1 : nnr ) if ( nrot > 0 ) then !$omp parallel default(shared) !-- For wavenumber 1 !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + (( alp ( ii ) * phic_nr ( 1 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 1 , ii )) / rtc ) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 1 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 1 , ii )) * vmax end do !$omp end do !$omp barrier !-- For wavenumber 2 if ( nrot > 1 ) then !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + 2.0d0 * r_inv ( ii ) * ( alp ( ii ) * phic_nr ( 2 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 2 , ii )) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + 2.0d0 * r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 2 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 2 , ii )) * vmax end do !$omp end do end if !$omp barrier !-- For wavenumber 3 if ( nrot > 2 ) then !$omp do schedule(runtime) private(ii) do ii = 1 , nnr tmp_VRT0_r ( ii ) = tmp_VRT0_r ( ii ) & & + 3.0d0 * (( alp ( ii ) * phic_nr ( 3 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( 3 , ii )) / rtc ) * vmax tmp_VDR0_r ( ii ) = tmp_VDR0_r ( ii ) & & + 3.0d0 * r_inv ( ii ) * ( alp ( ii ) * phis_nr ( 3 , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( 3 , ii )) * vmax end do !$omp end do end if !$omp end parallel VRT0_GVTD_r ( 1 : nnr ) = tmp_VRT0_r ( 1 : nnr ) VDR0_GVTD_r ( 1 : nnr ) = tmp_VDR0_r ( 1 : nnr ) end if call stdout ( \"Finish procedure.\" , \"calc_pseudo_GVTD0\" , 0 ) end subroutine calc_pseudo_GVTD0 subroutine calc_phi2sc ( nrot , vmax , rd , rdh , phis_nr , phic_nr , & & VRTns_r , VRTnc_r , VRRns_r , VRRnc_r ) !! Calculate sine and cosine components of Vt and VR for rot implicit none integer , intent ( in ) :: nrot !! Maximum wavenumber for stream function double precision , intent ( in ) :: vmax !! Scaling factor for velocity [m/s] double precision , intent ( in ) :: rd (:) !! Normalized radius [1] double precision , intent ( in ) :: rdh ( size ( rd ) + 1 ) !! Normalized radius [1] double precision , intent ( in ) :: phis_nr ( nrot , size ( rd ) + 1 ) !! Sine components of stream function [m2/s] double precision , intent ( in ) :: phic_nr ( nrot , size ( rd ) + 1 ) !! Cosine components of stream function [m2/s] double precision , intent ( out ) :: VRTns_r ( nrot , size ( rd )) !! Sine compoents of tangential wind [m/s] double precision , intent ( out ) :: VRTnc_r ( nrot , size ( rd )) !! Cosine components of tangential wind [m/s] double precision , intent ( out ) :: VRRns_r ( nrot , size ( rd )) !! Sine components of radial wind [m/s] double precision , intent ( out ) :: VRRnc_r ( nrot , size ( rd )) !! Cosine components of radial wind [m/s] integer :: ii , jj , kk , nnr , cstat double precision , dimension ( size ( rd )) :: dr , dr_inv , r_inv , alp call stdout ( \"Enter procedure.\" , \"calc_phi2sc\" , 0 ) nnr = size ( rd ) do ii = 1 , nnr dr ( ii ) = rdh ( ii + 1 ) - rdh ( ii ) dr_inv ( ii ) = 1.0d0 / dr ( ii ) alp ( ii ) = ( rd ( ii ) - rdh ( ii )) / ( rdh ( ii + 1 ) - rdh ( ii )) end do r_inv ( 1 : nnr ) = 1.0d0 / rd ( 1 : nnr ) if ( nrot > 0 ) then !$omp parallel default(shared) !$omp do schedule(runtime) private(kk,ii) do ii = 1 , nnr do kk = 1 , nrot VRTns_r ( kk , ii ) =- ( phis_nr ( kk , ii + 1 ) - phis_nr ( kk , ii )) * dr_inv ( ii ) * vmax VRTnc_r ( kk , ii ) =- ( phic_nr ( kk , ii + 1 ) - phic_nr ( kk , ii )) * dr_inv ( ii ) * vmax VRRns_r ( kk , ii ) =- dble ( kk ) * ( alp ( ii ) * phic_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phic_nr ( kk , ii )) * r_inv ( ii ) * vmax VRRnc_r ( kk , ii ) = dble ( kk ) * ( alp ( ii ) * phis_nr ( kk , ii + 1 ) + ( 1.0d0 - alp ( ii )) * phis_nr ( kk , ii )) * r_inv ( ii ) * vmax end do end do !$omp end do !$omp end parallel end if call stdout ( \"Finish procedure.\" , \"calc_phi2sc\" , 0 ) end subroutine calc_phi2sc end module GVTDX_main","tags":"","loc":"sourcefile/gvtdx_main_mod.f90.html"}]}